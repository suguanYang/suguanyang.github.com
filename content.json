[{"title":"","date":"2018-04-02T15:27:55.224Z","path":"2018/04/02/计算机系统结构/1/","text":"固件： 写入EROM或EPROM（可编程只读存储器）中的程序，通俗的理解就是固化的软件；更简单的说，固件就是BIOS的软件，但又与普通软件不同，他是固化在集成电路中的代码，负责控制和协调集成电路的功能。 硬件：计算机硬件的简称。与软件相对。电子计算机系统中的所有实体部分和设备的统称。从基本结构来讲，计算机分为五个部分：运算器，存储器，控制器，输入设备，输出设备。 计算机 - 电路板 - 集成电路 - 模块 - 单元 - 逻辑门 - 场效应管 计算及基本功能： 接收数据 - 存储数据 - 操作数据 - 输出结果 Application Software: Wriiten in high-level languageSystem Software: Compiler: translates HLL(hige-level language) code to machine code Operating System: Handling i/o Manageing memory and storage Scheduling tasks &amp; sharing resourceHardware: Processor, memory, I/O controllers Levels of Program Code: High-Level language: Level of abstraction closer to problem domain Provides for productivity and portablility Assembly language: Textual representation of instructions Hardware representation: Binaray digits(bits) Encode instructions and data 1 计算机系统的多层次结构： 1， M0 微程序（微指令）机器 2， M1 传统（机器指令）机器 3， M2 操作系统（作业控制） 机器 4， M3 汇编语言机器 5， M4 高级语言机器 6， M5 应用语言机器 其中1-2位实际机器（固件，硬件）。 3-6为虚拟机器(软件) 2 各个机器级的实现的依靠： 翻译和解释 3 翻译： translation 是先用转换程序将高一级机器级上实现的程序整个变化成低一级机器级上等效的程序，然后再低一级机器实现的技术。 4 解释： interpretation 是低级机器级上用它的一串语句或指令来仿真高级机器上的一条语句或指令的功能，通过高级机器语言程序中的每条语句或指令逐条解释来实现的技术 （高级语言翻译成汇编，通过指令去解释汇编） 5 M0-M5各级的实现方式： M0 用微程序（固件）实现 M1 用硬件实现 其他大多采用软件实现 6 虚拟机器的定义： 以软件为主实现的机器 7 实际机器的定义： 以硬件或固件实现的实际机器 8 透明的定义：","raw":"固件： 写入EROM或EPROM（可编程只读存储器）中的程序，通俗的理解就是固化的软件；更简单的说，固件就是BIOS的软件，但又与普通软件不同，他是固化在集成电路中的代码，负责控制和协调集成电路的功能。\n\n硬件：计算机硬件的简称。与软件相对。电子计算机系统中的所有实体部分和设备的统称。从基本结构来讲，计算机分为五个部分：运算器，存储器，控制器，输入设备，输出设备。\n\n计算机 - 电路板 - 集成电路 - 模块 - 单元 - 逻辑门 - 场效应管\n\n计算及基本功能：\t\n\t接收数据 - 存储数据 - 操作数据 - 输出结果\n\nApplication Software:\n\tWriiten in high-level language\nSystem Software:\n\tCompiler:\n\t\ttranslates HLL(hige-level language) code to machine code\n\tOperating System:\n\t\tHandling i/o\n\t\tManageing memory and storage\n\t\tScheduling tasks & sharing resource\nHardware:\n\tProcessor, memory, I/O controllers\n\nLevels of Program Code:\n\tHigh-Level language:\n\t\tLevel of abstraction closer to problem domain\n\t\tProvides for productivity and portablility\n\tAssembly language:\n\t\tTextual representation of instructions\n\tHardware representation:\n\t\tBinaray digits(bits)\n\t\tEncode instructions and data\n\n1 计算机系统的多层次结构：  \n\t1， M0 微程序（微指令）机器\n\t2， M1 传统（机器指令）机器\n\t3， M2 操作系统（作业控制） 机器\t  \n\t4， M3 汇编语言机器\n\t5， M4 高级语言机器\n\t6， M5 应用语言机器\n\n\t其中1-2位实际机器（固件，硬件）。 3-6为虚拟机器(软件)\n\n2 各个机器级的实现的依靠：\n\t翻译和解释\n\n3 翻译：\n\ttranslation 是先用转换程序将高一级机器级上实现的程序整个变化成低一级机器级上等效的程序，然后再低一级机器实现的技术。\n\n4 解释：\n\tinterpretation 是低级机器级上用它的一串语句或指令来仿真高级机器上的一条语句或指令的功能，通过高级机器语言程序中的每条语句或指令逐条解释来实现的技术\n\n\t（高级语言翻译成汇编，通过指令去解释汇编）\n\n5 M0-M5各级的实现方式：\n\tM0 用微程序（固件）实现\n\tM1 用硬件实现\n\t其他大多采用软件实现\n\n6 虚拟机器的定义：\n\t以软件为主实现的机器\n\n7 实际机器的定义：\n\t以硬件或固件实现的实际机器\n\n8 透明的定义：\n\t","content":"<p>固件： 写入EROM或EPROM（可编程只读存储器）中的程序，通俗的理解就是固化的软件；更简单的说，固件就是BIOS的软件，但又与普通软件不同，他是固化在集成电路中的代码，负责控制和协调集成电路的功能。</p>\n<p>硬件：计算机硬件的简称。与软件相对。电子计算机系统中的所有实体部分和设备的统称。从基本结构来讲，计算机分为五个部分：运算器，存储器，控制器，输入设备，输出设备。</p>\n<p>计算机 - 电路板 - 集成电路 - 模块 - 单元 - 逻辑门 - 场效应管</p>\n<p>计算及基本功能：<br>    接收数据 - 存储数据 - 操作数据 - 输出结果</p>\n<p>Application Software:<br>    Wriiten in high-level language<br>System Software:<br>    Compiler:<br>        translates HLL(hige-level language) code to machine code<br>    Operating System:<br>        Handling i/o<br>        Manageing memory and storage<br>        Scheduling tasks &amp; sharing resource<br>Hardware:<br>    Processor, memory, I/O controllers</p>\n<p>Levels of Program Code:<br>    High-Level language:<br>        Level of abstraction closer to problem domain<br>        Provides for productivity and portablility<br>    Assembly language:<br>        Textual representation of instructions<br>    Hardware representation:<br>        Binaray digits(bits)<br>        Encode instructions and data</p>\n<p>1 计算机系统的多层次结构：<br>    1， M0 微程序（微指令）机器<br>    2， M1 传统（机器指令）机器<br>    3， M2 操作系统（作业控制） 机器<br>    4， M3 汇编语言机器<br>    5， M4 高级语言机器<br>    6， M5 应用语言机器</p>\n<pre><code>其中1-2位实际机器（固件，硬件）。 3-6为虚拟机器(软件)\n</code></pre><p>2 各个机器级的实现的依靠：<br>    翻译和解释</p>\n<p>3 翻译：<br>    translation 是先用转换程序将高一级机器级上实现的程序整个变化成低一级机器级上等效的程序，然后再低一级机器实现的技术。</p>\n<p>4 解释：<br>    interpretation 是低级机器级上用它的一串语句或指令来仿真高级机器上的一条语句或指令的功能，通过高级机器语言程序中的每条语句或指令逐条解释来实现的技术</p>\n<pre><code>（高级语言翻译成汇编，通过指令去解释汇编）\n</code></pre><p>5 M0-M5各级的实现方式：<br>    M0 用微程序（固件）实现<br>    M1 用硬件实现<br>    其他大多采用软件实现</p>\n<p>6 虚拟机器的定义：<br>    以软件为主实现的机器</p>\n<p>7 实际机器的定义：<br>    以硬件或固件实现的实际机器</p>\n<p>8 透明的定义：</p>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:55.193Z","path":"2018/04/02/wechat小程序/bascal/","text":"分享功能： 最好按照这种格式写： onShareAppMessage: function() { return { title: this.data.team_name, path: /pages/team/team?activity_id=${this.data.activity_id}&amp;group_id=${this.data.group_id}&amp;token=${this.data.has_token.invite_token}&amp;group_token=${this.data.has_token.group_token}, success: function(res) { var shareTickets = res.shareTickets; if (shareTickets.length == 0) { return false; } wx.getShareInfo({ shareTicket: shareTickets[0], success: function(res) { var encryptedData = res.encryptedData; var iv = res.iv; } }) }, fail: function(res) { // 转发失败 } } }, 不要用es6的onShareAppMessage(){}这种写法","raw":"分享功能：\n\t最好按照这种格式写：\n\t\tonShareAppMessage: function() {\n\t        return {\n\t            title: this.data.team_name,\n\t            path: `/pages/team/team?activity_id=${this.data.activity_id}&group_id=${this.data.group_id}&token=${this.data.has_token.invite_token}&group_token=${this.data.has_token.group_token}`,\n\t            success: function(res) {\n\t                var shareTickets = res.shareTickets;\n\t                if (shareTickets.length == 0) {\n\t                    return false;\n\t                }\n\t                wx.getShareInfo({\n\t                    shareTicket: shareTickets[0],\n\t                    success: function(res) {\n\t                        var encryptedData = res.encryptedData;\n\t                        var iv = res.iv;\n\t                    }\n\t                })\n\t            },\n\t            fail: function(res) {\n\t                // 转发失败\n\t            }\n\t        }\n\t    },\n\n不要用es6的onShareAppMessage(){}这种写法","content":"<p>分享功能：<br>    最好按照这种格式写：<br>        onShareAppMessage: function() {<br>            return {<br>                title: this.data.team_name,<br>                path: <code>/pages/team/team?activity_id=${this.data.activity_id}&amp;group_id=${this.data.group_id}&amp;token=${this.data.has_token.invite_token}&amp;group_token=${this.data.has_token.group_token}</code>,<br>                success: function(res) {<br>                    var shareTickets = res.shareTickets;<br>                    if (shareTickets.length == 0) {<br>                        return false;<br>                    }<br>                    wx.getShareInfo({<br>                        shareTicket: shareTickets[0],<br>                        success: function(res) {<br>                            var encryptedData = res.encryptedData;<br>                            var iv = res.iv;<br>                        }<br>                    })<br>                },<br>                fail: function(res) {<br>                    // 转发失败<br>                }<br>            }<br>        },</p>\n<p>不要用es6的onShareAppMessage(){}这种写法</p>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:55.167Z","path":"2018/04/02/webpack/configuration/","text":"loader: loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ module.exports = { module: { rules: [ { test: /.css$/, use: ‘css-loader’ }, { test: /.ts$/, use: ‘ts-loader’ } ] }}; 使用 Loader在你的应用程序中，有三种使用 loader 的方式： 配置（推荐）：在 webpack.config.js 文件中指定 loader。 内联：在每个 import 语句中显式指定 loader。 CLI：在 shell 命令中指定它们。 注： v2后loaders改为rules Entry多页面应用程序webpack.config.js const config = { entry: { pageOne: ‘./src/pageOne/index.js’, pageTwo: ‘./src/pageTwo/index.js’, pageThree: ‘./src/pageThree/index.js’ }};","raw":"**loader:**\t\n\n- loader 用于对模块的源代码进行转换。loader 可以使你在 import 或\"加载\"模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！\n\n<code>module.exports = {\n  module: {\n    rules: [\n      { test: /\\.css$/, use: 'css-loader' },\n      { test: /\\.ts$/, use: 'ts-loader' }\n    ]\n  }\n};</code>\n\n# 使用 Loader #\n在你的应用程序中，有三种使用 loader 的方式：\n- \n- 配置（推荐）：在 webpack.config.js 文件中指定 loader。\n- 内联：在每个 import 语句中显式指定 loader。\n- CLI：在 shell 命令中指定它们。\n\n注： v2后loaders改为rules\n\n# Entry #\n\n**多页面应用程序**\n*webpack.config.js*\n\n<code>const config = {\n  entry: {\n    pageOne: './src/pageOne/index.js',\n    pageTwo: './src/pageTwo/index.js',\n    pageThree: './src/pageThree/index.js'\n  }\n};</code>","content":"<p><strong>loader:</strong>    </p>\n<ul>\n<li>loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！</li>\n</ul>\n<p><code>module.exports = {<br>  module: {<br>    rules: [<br>      { test: /.css$/, use: ‘css-loader’ },<br>      { test: /.ts$/, use: ‘ts-loader’ }<br>    ]<br>  }<br>};</code></p>\n<h1 id=\"使用-Loader\"><a href=\"#使用-Loader\" class=\"headerlink\" title=\"使用 Loader\"></a>使用 Loader</h1><p>在你的应用程序中，有三种使用 loader 的方式：</p>\n<ul>\n<li></li>\n<li>配置（推荐）：在 webpack.config.js 文件中指定 loader。</li>\n<li>内联：在每个 import 语句中显式指定 loader。</li>\n<li>CLI：在 shell 命令中指定它们。</li>\n</ul>\n<p>注： v2后loaders改为rules</p>\n<h1 id=\"Entry\"><a href=\"#Entry\" class=\"headerlink\" title=\"Entry\"></a>Entry</h1><p><strong>多页面应用程序</strong><br><em>webpack.config.js</em></p>\n<p><code>const config = {<br>  entry: {<br>    pageOne: ‘./src/pageOne/index.js’,<br>    pageTwo: ‘./src/pageTwo/index.js’,<br>    pageThree: ‘./src/pageThree/index.js’<br>  }<br>};</code></p>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:55.138Z","path":"2018/04/02/ts/泛型/","text":"function identity(arg: T): T { return arg;} 这里T是类型变量，T帮助我们捕获用户传入的类型（ex：number），之后我们就可以使用这个类型。之后我们再次使用了T当作返回值类型，现在我们可以知道参数类型与返回值类型是相同的了。这允许我们跟踪函数里使用的类型信息。 我们把这个版本的identity函数叫做泛型，因为它可以适用于多个类型。不同于使用any，他不会丢失信息，像第一个例子那样保持准确性。传入什么类型便会返回什么类型。 我们定义了泛型函数后，可以使用两种方法使用。第一种是，传入所以的参数，包括类型参数：let output = identity(“myString”); // type of output will be ‘string’ 这里我们明确的指定了T是string类型，并作为一个参数传给函数，使用了&lt;&gt;而不是（）。第二种方法将会更简单，我们利用了类型推论–即编译器会自动的识别，根据传入的参数类型自动的帮我们确定T的类型。let output = identity(“myString”); // type of output will be ‘string’ 注意我们么们没有明确的传入类型in尖括号，编译器会查看参数，并将T也设为参数类型，类型函数推断帮助我们保持代码的精简与可读性，但是有些时候你也需要想上面那样明确地传入类型参数当编译器不能自动推论，这可能在比较复杂的情况下出现。 当你开始使用泛型函数，你会注意到当你创建像identity这样的泛型函数时，编译器会在函数内使用任何的泛型参数类型正确的执行，实际上你应该传入任何类型的参数。","raw":"function identity<T>(arg: T): T {\n    return arg;\n}\n\n这里T是类型变量，T帮助我们捕获用户传入的类型（ex：number），之后我们就可以使用这个类型。之后我们再次使用了T当作返回值类型，现在我们可以知道参数类型与返回值类型是相同的了。这允许我们跟踪函数里使用的类型信息。\n\n我们把这个版本的identity函数叫做泛型，因为它可以适用于多个类型。不同于使用any，他不会丢失信息，像第一个例子那样保持准确性。传入什么类型便会返回什么类型。\n\n我们定义了泛型函数后，可以使用两种方法使用。第一种是，传入所以的参数，包括类型参数：\nlet output = identity<string>(\"myString\");  // type of output will be 'string'\n\n这里我们明确的指定了T是string类型，并作为一个参数传给函数，使用了<>而不是（）。\n第二种方法将会更简单，我们利用了类型推论--即编译器会自动的识别，根据传入的参数类型自动的帮我们确定T的类型。\nlet output = identity(\"myString\");  // type of output will be 'string'\n\n注意我们么们没有明确的传入类型in尖括号，编译器会查看参数，并将T也设为参数类型，类型函数推断帮助我们保持代码的精简与可读性，但是有些时候你也需要想上面那样明确地传入类型参数当编译器不能自动推论，这可能在比较复杂的情况下出现。\n\n当你开始使用泛型函数，你会注意到当你创建像identity这样的泛型函数时，编译器会在函数内使用任何的泛型参数类型正确的执行，实际上你应该传入任何类型的参数。","content":"<p>function identity<t>(arg: T): T {<br>    return arg;<br>}</t></p>\n<p>这里T是类型变量，T帮助我们捕获用户传入的类型（ex：number），之后我们就可以使用这个类型。之后我们再次使用了T当作返回值类型，现在我们可以知道参数类型与返回值类型是相同的了。这允许我们跟踪函数里使用的类型信息。</p>\n<p>我们把这个版本的identity函数叫做泛型，因为它可以适用于多个类型。不同于使用any，他不会丢失信息，像第一个例子那样保持准确性。传入什么类型便会返回什么类型。</p>\n<p>我们定义了泛型函数后，可以使用两种方法使用。第一种是，传入所以的参数，包括类型参数：<br>let output = identity<string>(“myString”);  // type of output will be ‘string’</string></p>\n<p>这里我们明确的指定了T是string类型，并作为一个参数传给函数，使用了&lt;&gt;而不是（）。<br>第二种方法将会更简单，我们利用了类型推论–即编译器会自动的识别，根据传入的参数类型自动的帮我们确定T的类型。<br>let output = identity(“myString”);  // type of output will be ‘string’</p>\n<p>注意我们么们没有明确的传入类型in尖括号，编译器会查看参数，并将T也设为参数类型，类型函数推断帮助我们保持代码的精简与可读性，但是有些时候你也需要想上面那样明确地传入类型参数当编译器不能自动推论，这可能在比较复杂的情况下出现。</p>\n<p>当你开始使用泛型函数，你会注意到当你创建像identity这样的泛型函数时，编译器会在函数内使用任何的泛型参数类型正确的执行，实际上你应该传入任何类型的参数。</p>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:55.107Z","path":"2018/04/02/ts/library/","text":"概述一般来讲，你组织声明文件的方式取决于库是如何被使用的。 在JavaScript中一个库有很多使用方式，这就需要你书写声明文件去匹配它们。 这篇指南涵盖了如何识别常见库的模式，和怎样书写符合相应模式的声明文件。 针对每种主要的库的组织模式，在模版一节都有对应的文件。 你可以利用它们帮助你快速上手。 识别库的类型首先，我们先看一下TypeScript声明文件能够表示的库的类型。 这里会简单展示每种类型的库的使用方式，如何去书写，还有一些真实案例。 识别库的类型是书写声明文件的第一步。 我们将会给出一些提示，关于怎样通过库的使用方法及其源码来识别库的类型。 根据库的文档及组织结构不同，这两种方式可能一个会比另外的那个简单一些。 我们推荐你使用任意你喜欢的方式。 全局库全局库是指能在全局命名空间下访问的（例如：不需要使用任何形式的import）。 许多库都是简单的暴露出一个或多个全局变量。 比如，如果你使用过jQuery，$变量可以被够简单的引用： $(() =&gt; { console.log(‘hello!’); } );你经常会在全局库的指南文档上看到如何在HTML里用脚本标签引用库： 目前，大多数流行的全局访问型库实际上都以UMD库的形式进行书写（见后文）。 UMD库的文档很难与全局库文档两者之间难以区分。 在书写全局声明文件前，一定要确认一下库是否真的不是UMD。 从代码上识别全局库全局库的代码通常都十分简单。 一个全局的“Hello, world”库可能是这样的： function createGreeting(s) { return “Hello, “ + s;}或这样： window.createGreeting = function(s) { return “Hello, “ + s;}当你查看全局库的源代码时，你通常会看到： 顶级的var语句或function声明一个或多个赋值语句到window.someName假设DOM原始值像document或window是存在的你不会看到： 检查是否使用或如何使用模块加载器，比如require或defineCommonJS/Node.js风格的导入如var fs = require(“fs”);define(…)调用文档里说明了如何去require或导入这个库全局库的例子由于把一个全局库转变成UMD库是非常容易的，所以很少流行的库还再使用全局的风格。 然而，小型的且需要DOM（或没有依赖）的库可能还是全局类型的。 全局库模版模版文件global.d.ts定义了myLib库作为例子。 一定要阅读”防止命名冲突”补充说明。 模块化库一些库只能工作在模块加载器的环境下。 比如，像express只能在Node.js里工作所以必须使用CommonJS的require函数加载。 ECMAScript 2015（也就是ES2015，ECMAScript 6或ES6），CommonJS和RequireJS具有相似的导入一个模块的表示方法。 例如，对于JavaScript CommonJS （Node.js），有下面的代码 var fs = require(“fs”);对于TypeScript或ES6，import关键字也具有相同的作用： import fs = require(“fs”);你通常会在模块化库的文档里看到如下说明： var someLib = require(‘someLib’);或 define(…, [‘someLib’], function(someLib) { });与全局模块一样，你也可能会在UMD模块的文档里看到这些例子，因此要仔细查看源码和文档。 从代码上识别模块化库模块库至少会包含下列具有代表性的条目之一： 无条件的调用require或define像import * as a from ‘b’; or export c;这样的声明赋值给exports或module.exports它们极少包含： 对window或global的赋值模块化库的例子许多流行的Node.js库都是这种模块化的，例如express，gulp和request。 UMDUMD模块是指那些既可以作为模块使用（通过导入）又可以作为全局（在没有模块加载器的环境里）使用的模块。 许多流行的库，比如Moment.js，就是这样的形式。 比如，在Node.js或RequireJS里，你可以这样写： import moment = require(“moment”);console.log(moment.format());然而在纯净的浏览器环境里你也可以这样写： console.log(moment.format());识别UMD库UMD模块会检查是否存在模块加载器环境。 这是非常形容观察到的模块，它们会像下面这样： (function (root, factory) { if (typeof define === “function” &amp;&amp; define.amd) { define([“libName”], factory); } else if (typeof module === “object” &amp;&amp; module.exports) { module.exports = factory(require(“libName”)); } else { root.returnExports = factory(root.libName); }}(this, function (b) {如果你在库的源码里看到了typeof define，typeof window，或typeof module这样的测试，尤其是在文件的顶端，那么它几乎就是一个UMD库。 UMD库的文档里经常会包含通过require“在Node.js里使用”例子， 和“在浏览器里使用”的例子，展示如何使用标签去加载脚本。 UMD库的例子大多数流行的库现在都能够被当成UMD包。 比如jQuery,Moment.js,lodash和许多其它的。 模版针对模块有三种可用的模块， module.d.ts, module-class.d.ts and module-function.d.ts. 使用module-function.d.ts，如果模块能够作为函数调用。 var x = require(“foo”);// Note: calling ‘x’ as a functionvar y = x(42);一定要阅读补充说明： “ES6模块调用签名的影响” 使用module-class.d.ts如果模块能够使用new来构造： var x = require(“bar”);// Note: using ‘new’ operator on the imported variablevar y = new x(“hello”);相同的补充说明作用于这些模块。 如果模块不能被调用或构造，使用module.d.ts文件。 模块插件或UMD插件一个模块插件可以改变一个模块的结构（UMD或模块）。 例如，在Moment.js里，moment-range添加了新的range方法到monent对象。 对于声明文件的目标，我们会写相同的代码不论被改变的模块是一个纯粹的模块还是UMD模块。 模版使用module-plugin.d.ts模版。 全局插件一个全局插件是全局代码，它们会改变全局对象的结构。 对于全局修改的模块，在运行时存在冲突的可能。 比如，一些库往Array.prototype或String.prototype里添加新的方法。 识别全局插件全局通常很容易地从它们的文档识别出来。 你会看到像下面这样的例子： var x = “hello, world”;// Creates new methods on built-in typesconsole.log(x.startsWithHello()); var y = [1, 2, 3];// Creates new methods on built-in typesconsole.log(y.reverseAndSort());模版使用global-plugin.d.ts模版。 全局修改的模块当一个全局修改的模块被导入的时候，它们会改变全局作用域里的值。 比如，存在一些库它们添加新的成员到String.prototype当导入它们的时候。 这种模式很危险，因为可能造成运行时的冲突， 但是我们仍然可以为它们书写声明文件。 识别全局修改的模块全局修改的模块通常可以很容易地从它们的文档识别出来。 通常来讲，它们与全局插件相似，但是需要require调用来激活它们的效果。 你可能会看到像下面这样的文档: // ‘require’ call that doesn’t use its return valuevar unused = require(“magic-string-time”);/ or /require(“magic-string-time”); var x = “hello, world”;// Creates new methods on built-in typesconsole.log(x.startsWithHello()); var y = [1, 2, 3];// Creates new methods on built-in typesconsole.log(y.reverseAndSort());模版使用global-modifying-module.d.ts模版。 使用依赖可能会有以下几种依赖。 依赖全局库如果你的库依赖于某个全局库，使用/// 指令： /// function getThing(): someLib.thing;依赖模块如果你的库依赖于模块，使用import语句： import * as moment from “moment”; function getThing(): moment;依赖UMD库从全局库如果你的全局库依赖于某个UMD模块，使用/// &lt;reference types指令： /// function getThing(): moment;从一个模块或UMD库如果你的模块或UMD库依赖于一个UMD库，使用import语句： import * as someLib from ‘someLib’;不要使用/// &lt;reference指令去声明UMD库的依赖！ 补充说明防止命名冲突注意，在书写全局声明文件时，允许在全局作用域里定义很多类型。 我们十分不建义这样做，当一个工程里有许多声明文件时，它会导致无法处理的命名冲突。 一个简单的规则是使用库定义的全局变量名来声明命名空间类型。 比如，库定义了一个全局的值cats，你可以这样写 declare namespace cats { interface KittySettings { }}不要 // at top-levelinterface CatsKittySettings { }这样也保证了库在转换成UMD的时候没有任何的破坏式改变，对于声明文件用户来说。 ES6模块插件的影响一些插件添加或修改已存在的顶层模块的导出部分。 当然这在CommonJS和其它加载器里是允许的，ES模块被当作是不可改变的因此这种模式就不可行了。 因为TypeScript是能不预知加载器类型的，所以没没在编译时保证，但是开发者如果要转到ES6模块加载器上应该注意这一点。 ES6模块调用签名的影响很多流行库，比如Express，暴露出自己作为可以调用的函数。 比如，典型的Express使用方法如下： import exp = require(“express”);var app = exp();在ES6模块加载器里，顶层的对象（这里以exp导入）只能具有属性； 顶层的模块对象永远不能被调用。 十分常见的解决方法是定义一个default导出到一个可调用的/可构造的对象； 一会模块加载器助手工具能够自己探测到这种情况并且使用default导出来替换顶层对象。","raw":"概述\n一般来讲，你组织声明文件的方式取决于库是如何被使用的。 在JavaScript中一个库有很多使用方式，这就需要你书写声明文件去匹配它们。 这篇指南涵盖了如何识别常见库的模式，和怎样书写符合相应模式的声明文件。\n\n针对每种主要的库的组织模式，在模版一节都有对应的文件。 你可以利用它们帮助你快速上手。\n\n识别库的类型\n首先，我们先看一下TypeScript声明文件能够表示的库的类型。 这里会简单展示每种类型的库的使用方式，如何去书写，还有一些真实案例。\n\n识别库的类型是书写声明文件的第一步。 我们将会给出一些提示，关于怎样通过库的使用方法及其源码来识别库的类型。 根据库的文档及组织结构不同，这两种方式可能一个会比另外的那个简单一些。 我们推荐你使用任意你喜欢的方式。\n\n全局库\n全局库是指能在全局命名空间下访问的（例如：不需要使用任何形式的import）。 许多库都是简单的暴露出一个或多个全局变量。 比如，如果你使用过jQuery，$变量可以被够简单的引用：\n\n$(() => { console.log('hello!'); } );\n你经常会在全局库的指南文档上看到如何在HTML里用脚本标签引用库：\n\n<script src=\"http://a.great.cdn.for/someLib.js\"></script>\n目前，大多数流行的全局访问型库实际上都以UMD库的形式进行书写（见后文）。 UMD库的文档很难与全局库文档两者之间难以区分。 在书写全局声明文件前，一定要确认一下库是否真的不是UMD。\n\n从代码上识别全局库\n全局库的代码通常都十分简单。 一个全局的“Hello, world”库可能是这样的：\n\nfunction createGreeting(s) {\n    return \"Hello, \" + s;\n}\n或这样：\n\nwindow.createGreeting = function(s) {\n    return \"Hello, \" + s;\n}\n当你查看全局库的源代码时，你通常会看到：\n\n顶级的var语句或function声明\n一个或多个赋值语句到window.someName\n假设DOM原始值像document或window是存在的\n你不会看到：\n\n检查是否使用或如何使用模块加载器，比如require或define\nCommonJS/Node.js风格的导入如var fs = require(\"fs\");\ndefine(...)调用\n文档里说明了如何去require或导入这个库\n全局库的例子\n由于把一个全局库转变成UMD库是非常容易的，所以很少流行的库还再使用全局的风格。 然而，小型的且需要DOM（或没有依赖）的库可能还是全局类型的。\n\n全局库模版\n模版文件global.d.ts定义了myLib库作为例子。 一定要阅读\"防止命名冲突\"补充说明。\n\n模块化库\n一些库只能工作在模块加载器的环境下。 比如，像express只能在Node.js里工作所以必须使用CommonJS的require函数加载。\n\nECMAScript 2015（也就是ES2015，ECMAScript 6或ES6），CommonJS和RequireJS具有相似的导入一个模块的表示方法。 例如，对于JavaScript CommonJS （Node.js），有下面的代码\n\nvar fs = require(\"fs\");\n对于TypeScript或ES6，import关键字也具有相同的作用：\n\nimport fs = require(\"fs\");\n你通常会在模块化库的文档里看到如下说明：\n\nvar someLib = require('someLib');\n或\n\ndefine(..., ['someLib'], function(someLib) {\n\n});\n与全局模块一样，你也可能会在UMD模块的文档里看到这些例子，因此要仔细查看源码和文档。\n\n从代码上识别模块化库\n模块库至少会包含下列具有代表性的条目之一：\n\n无条件的调用require或define\n像import * as a from 'b'; or export c;这样的声明\n赋值给exports或module.exports\n它们极少包含：\n\n对window或global的赋值\n模块化库的例子\n许多流行的Node.js库都是这种模块化的，例如express，gulp和request。\n\nUMD\nUMD模块是指那些既可以作为模块使用（通过导入）又可以作为全局（在没有模块加载器的环境里）使用的模块。 许多流行的库，比如Moment.js，就是这样的形式。 比如，在Node.js或RequireJS里，你可以这样写：\n\nimport moment = require(\"moment\");\nconsole.log(moment.format());\n然而在纯净的浏览器环境里你也可以这样写：\n\nconsole.log(moment.format());\n识别UMD库\nUMD模块会检查是否存在模块加载器环境。 这是非常形容观察到的模块，它们会像下面这样：\n\n(function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define([\"libName\"], factory);\n    } else if (typeof module === \"object\" && module.exports) {\n        module.exports = factory(require(\"libName\"));\n    } else {\n        root.returnExports = factory(root.libName);\n    }\n}(this, function (b) {\n如果你在库的源码里看到了typeof define，typeof window，或typeof module这样的测试，尤其是在文件的顶端，那么它几乎就是一个UMD库。\n\nUMD库的文档里经常会包含通过require“在Node.js里使用”例子， 和“在浏览器里使用”的例子，展示如何使用<script>标签去加载脚本。\n\nUMD库的例子\n大多数流行的库现在都能够被当成UMD包。 比如jQuery,Moment.js,lodash和许多其它的。\n\n模版\n针对模块有三种可用的模块， module.d.ts, module-class.d.ts and module-function.d.ts.\n\n使用module-function.d.ts，如果模块能够作为函数调用。\n\nvar x = require(\"foo\");\n// Note: calling 'x' as a function\nvar y = x(42);\n一定要阅读补充说明： “ES6模块调用签名的影响”\n\n使用module-class.d.ts如果模块能够使用new来构造：\n\nvar x = require(\"bar\");\n// Note: using 'new' operator on the imported variable\nvar y = new x(\"hello\");\n相同的补充说明作用于这些模块。\n\n如果模块不能被调用或构造，使用module.d.ts文件。\n\n模块插件或UMD插件\n一个模块插件可以改变一个模块的结构（UMD或模块）。 例如，在Moment.js里，moment-range添加了新的range方法到monent对象。\n\n对于声明文件的目标，我们会写相同的代码不论被改变的模块是一个纯粹的模块还是UMD模块。\n\n模版\n使用module-plugin.d.ts模版。\n\n全局插件\n一个全局插件是全局代码，它们会改变全局对象的结构。 对于全局修改的模块，在运行时存在冲突的可能。\n\n比如，一些库往Array.prototype或String.prototype里添加新的方法。\n\n识别全局插件\n全局通常很容易地从它们的文档识别出来。\n\n你会看到像下面这样的例子：\n\nvar x = \"hello, world\";\n// Creates new methods on built-in types\nconsole.log(x.startsWithHello());\n\nvar y = [1, 2, 3];\n// Creates new methods on built-in types\nconsole.log(y.reverseAndSort());\n模版\n使用global-plugin.d.ts模版。\n\n全局修改的模块\n当一个全局修改的模块被导入的时候，它们会改变全局作用域里的值。 比如，存在一些库它们添加新的成员到String.prototype当导入它们的时候。 这种模式很危险，因为可能造成运行时的冲突， 但是我们仍然可以为它们书写声明文件。\n\n识别全局修改的模块\n全局修改的模块通常可以很容易地从它们的文档识别出来。 通常来讲，它们与全局插件相似，但是需要require调用来激活它们的效果。\n\n你可能会看到像下面这样的文档:\n\n// 'require' call that doesn't use its return value\nvar unused = require(\"magic-string-time\");\n/* or */\nrequire(\"magic-string-time\");\n\nvar x = \"hello, world\";\n// Creates new methods on built-in types\nconsole.log(x.startsWithHello());\n\nvar y = [1, 2, 3];\n// Creates new methods on built-in types\nconsole.log(y.reverseAndSort());\n模版\n使用global-modifying-module.d.ts模版。\n\n使用依赖\n可能会有以下几种依赖。\n\n依赖全局库\n如果你的库依赖于某个全局库，使用/// <reference types=\"...\" />指令：\n\n/// <reference types=\"someLib\" />\n\nfunction getThing(): someLib.thing;\n依赖模块\n如果你的库依赖于模块，使用import语句：\n\nimport * as moment from \"moment\";\n\nfunction getThing(): moment;\n依赖UMD库\n从全局库\n如果你的全局库依赖于某个UMD模块，使用/// <reference types指令：\n\n/// <reference types=\"moment\" />\n\nfunction getThing(): moment;\n从一个模块或UMD库\n如果你的模块或UMD库依赖于一个UMD库，使用import语句：\n\nimport * as someLib from 'someLib';\n不要使用/// <reference指令去声明UMD库的依赖！\n\n补充说明\n防止命名冲突\n注意，在书写全局声明文件时，允许在全局作用域里定义很多类型。 我们十分不建义这样做，当一个工程里有许多声明文件时，它会导致无法处理的命名冲突。\n\n一个简单的规则是使用库定义的全局变量名来声明命名空间类型。 比如，库定义了一个全局的值cats，你可以这样写\n\ndeclare namespace cats {\n    interface KittySettings { }\n}\n不要\n\n// at top-level\ninterface CatsKittySettings { }\n这样也保证了库在转换成UMD的时候没有任何的破坏式改变，对于声明文件用户来说。\n\nES6模块插件的影响\n一些插件添加或修改已存在的顶层模块的导出部分。 当然这在CommonJS和其它加载器里是允许的，ES模块被当作是不可改变的因此这种模式就不可行了。 因为TypeScript是能不预知加载器类型的，所以没没在编译时保证，但是开发者如果要转到ES6模块加载器上应该注意这一点。\n\nES6模块调用签名的影响\n很多流行库，比如Express，暴露出自己作为可以调用的函数。 比如，典型的Express使用方法如下：\n\nimport exp = require(\"express\");\nvar app = exp();\n在ES6模块加载器里，顶层的对象（这里以exp导入）只能具有属性； 顶层的模块对象永远不能被调用。 十分常见的解决方法是定义一个default导出到一个可调用的/可构造的对象； 一会模块加载器助手工具能够自己探测到这种情况并且使用default导出来替换顶层对象。","content":"<p>概述<br>一般来讲，你组织声明文件的方式取决于库是如何被使用的。 在JavaScript中一个库有很多使用方式，这就需要你书写声明文件去匹配它们。 这篇指南涵盖了如何识别常见库的模式，和怎样书写符合相应模式的声明文件。</p>\n<p>针对每种主要的库的组织模式，在模版一节都有对应的文件。 你可以利用它们帮助你快速上手。</p>\n<p>识别库的类型<br>首先，我们先看一下TypeScript声明文件能够表示的库的类型。 这里会简单展示每种类型的库的使用方式，如何去书写，还有一些真实案例。</p>\n<p>识别库的类型是书写声明文件的第一步。 我们将会给出一些提示，关于怎样通过库的使用方法及其源码来识别库的类型。 根据库的文档及组织结构不同，这两种方式可能一个会比另外的那个简单一些。 我们推荐你使用任意你喜欢的方式。</p>\n<p>全局库<br>全局库是指能在全局命名空间下访问的（例如：不需要使用任何形式的import）。 许多库都是简单的暴露出一个或多个全局变量。 比如，如果你使用过jQuery，$变量可以被够简单的引用：</p>\n<p>$(() =&gt; { console.log(‘hello!’); } );<br>你经常会在全局库的指南文档上看到如何在HTML里用脚本标签引用库：</p>\n<p><script src=\"http://a.great.cdn.for/someLib.js\"></script><br>目前，大多数流行的全局访问型库实际上都以UMD库的形式进行书写（见后文）。 UMD库的文档很难与全局库文档两者之间难以区分。 在书写全局声明文件前，一定要确认一下库是否真的不是UMD。</p>\n<p>从代码上识别全局库<br>全局库的代码通常都十分简单。 一个全局的“Hello, world”库可能是这样的：</p>\n<p>function createGreeting(s) {<br>    return “Hello, “ + s;<br>}<br>或这样：</p>\n<p>window.createGreeting = function(s) {<br>    return “Hello, “ + s;<br>}<br>当你查看全局库的源代码时，你通常会看到：</p>\n<p>顶级的var语句或function声明<br>一个或多个赋值语句到window.someName<br>假设DOM原始值像document或window是存在的<br>你不会看到：</p>\n<p>检查是否使用或如何使用模块加载器，比如require或define<br>CommonJS/Node.js风格的导入如var fs = require(“fs”);<br>define(…)调用<br>文档里说明了如何去require或导入这个库<br>全局库的例子<br>由于把一个全局库转变成UMD库是非常容易的，所以很少流行的库还再使用全局的风格。 然而，小型的且需要DOM（或没有依赖）的库可能还是全局类型的。</p>\n<p>全局库模版<br>模版文件global.d.ts定义了myLib库作为例子。 一定要阅读”防止命名冲突”补充说明。</p>\n<p>模块化库<br>一些库只能工作在模块加载器的环境下。 比如，像express只能在Node.js里工作所以必须使用CommonJS的require函数加载。</p>\n<p>ECMAScript 2015（也就是ES2015，ECMAScript 6或ES6），CommonJS和RequireJS具有相似的导入一个模块的表示方法。 例如，对于JavaScript CommonJS （Node.js），有下面的代码</p>\n<p>var fs = require(“fs”);<br>对于TypeScript或ES6，import关键字也具有相同的作用：</p>\n<p>import fs = require(“fs”);<br>你通常会在模块化库的文档里看到如下说明：</p>\n<p>var someLib = require(‘someLib’);<br>或</p>\n<p>define(…, [‘someLib’], function(someLib) {</p>\n<p>});<br>与全局模块一样，你也可能会在UMD模块的文档里看到这些例子，因此要仔细查看源码和文档。</p>\n<p>从代码上识别模块化库<br>模块库至少会包含下列具有代表性的条目之一：</p>\n<p>无条件的调用require或define<br>像import * as a from ‘b’; or export c;这样的声明<br>赋值给exports或module.exports<br>它们极少包含：</p>\n<p>对window或global的赋值<br>模块化库的例子<br>许多流行的Node.js库都是这种模块化的，例如express，gulp和request。</p>\n<p>UMD<br>UMD模块是指那些既可以作为模块使用（通过导入）又可以作为全局（在没有模块加载器的环境里）使用的模块。 许多流行的库，比如Moment.js，就是这样的形式。 比如，在Node.js或RequireJS里，你可以这样写：</p>\n<p>import moment = require(“moment”);<br>console.log(moment.format());<br>然而在纯净的浏览器环境里你也可以这样写：</p>\n<p>console.log(moment.format());<br>识别UMD库<br>UMD模块会检查是否存在模块加载器环境。 这是非常形容观察到的模块，它们会像下面这样：</p>\n<p>(function (root, factory) {<br>    if (typeof define === “function” &amp;&amp; define.amd) {<br>        define([“libName”], factory);<br>    } else if (typeof module === “object” &amp;&amp; module.exports) {<br>        module.exports = factory(require(“libName”));<br>    } else {<br>        root.returnExports = factory(root.libName);<br>    }<br>}(this, function (b) {<br>如果你在库的源码里看到了typeof define，typeof window，或typeof module这样的测试，尤其是在文件的顶端，那么它几乎就是一个UMD库。</p>\n<p>UMD库的文档里经常会包含通过require“在Node.js里使用”例子， 和“在浏览器里使用”的例子，展示如何使用<script>标签去加载脚本。</p>\n<p>UMD库的例子<br>大多数流行的库现在都能够被当成UMD包。 比如jQuery,Moment.js,lodash和许多其它的。</p>\n<p>模版<br>针对模块有三种可用的模块， module.d.ts, module-class.d.ts and module-function.d.ts.</p>\n<p>使用module-function.d.ts，如果模块能够作为函数调用。</p>\n<p>var x = require(“foo”);<br>// Note: calling ‘x’ as a function<br>var y = x(42);<br>一定要阅读补充说明： “ES6模块调用签名的影响”</p>\n<p>使用module-class.d.ts如果模块能够使用new来构造：</p>\n<p>var x = require(“bar”);<br>// Note: using ‘new’ operator on the imported variable<br>var y = new x(“hello”);<br>相同的补充说明作用于这些模块。</p>\n<p>如果模块不能被调用或构造，使用module.d.ts文件。</p>\n<p>模块插件或UMD插件<br>一个模块插件可以改变一个模块的结构（UMD或模块）。 例如，在Moment.js里，moment-range添加了新的range方法到monent对象。</p>\n<p>对于声明文件的目标，我们会写相同的代码不论被改变的模块是一个纯粹的模块还是UMD模块。</p>\n<p>模版<br>使用module-plugin.d.ts模版。</p>\n<p>全局插件<br>一个全局插件是全局代码，它们会改变全局对象的结构。 对于全局修改的模块，在运行时存在冲突的可能。</p>\n<p>比如，一些库往Array.prototype或String.prototype里添加新的方法。</p>\n<p>识别全局插件<br>全局通常很容易地从它们的文档识别出来。</p>\n<p>你会看到像下面这样的例子：</p>\n<p>var x = “hello, world”;<br>// Creates new methods on built-in types<br>console.log(x.startsWithHello());</p>\n<p>var y = [1, 2, 3];<br>// Creates new methods on built-in types<br>console.log(y.reverseAndSort());<br>模版<br>使用global-plugin.d.ts模版。</p>\n<p>全局修改的模块<br>当一个全局修改的模块被导入的时候，它们会改变全局作用域里的值。 比如，存在一些库它们添加新的成员到String.prototype当导入它们的时候。 这种模式很危险，因为可能造成运行时的冲突， 但是我们仍然可以为它们书写声明文件。</p>\n<p>识别全局修改的模块<br>全局修改的模块通常可以很容易地从它们的文档识别出来。 通常来讲，它们与全局插件相似，但是需要require调用来激活它们的效果。</p>\n<p>你可能会看到像下面这样的文档:</p>\n<p>// ‘require’ call that doesn’t use its return value<br>var unused = require(“magic-string-time”);<br>/<em> or </em>/<br>require(“magic-string-time”);</p>\n<p>var x = “hello, world”;<br>// Creates new methods on built-in types<br>console.log(x.startsWithHello());</p>\n<p>var y = [1, 2, 3];<br>// Creates new methods on built-in types<br>console.log(y.reverseAndSort());<br>模版<br>使用global-modifying-module.d.ts模版。</p>\n<p>使用依赖<br>可能会有以下几种依赖。</p>\n<p>依赖全局库<br>如果你的库依赖于某个全局库，使用/// <reference types=\"...\" />指令：</p>\n<p>/// <reference types=\"someLib\" /></p>\n<p>function getThing(): someLib.thing;<br>依赖模块<br>如果你的库依赖于模块，使用import语句：</p>\n<p>import * as moment from “moment”;</p>\n<p>function getThing(): moment;<br>依赖UMD库<br>从全局库<br>如果你的全局库依赖于某个UMD模块，使用/// &lt;reference types指令：</p>\n<p>/// <reference types=\"moment\" /></p>\n<p>function getThing(): moment;<br>从一个模块或UMD库<br>如果你的模块或UMD库依赖于一个UMD库，使用import语句：</p>\n<p>import * as someLib from ‘someLib’;<br>不要使用/// &lt;reference指令去声明UMD库的依赖！</p>\n<p>补充说明<br>防止命名冲突<br>注意，在书写全局声明文件时，允许在全局作用域里定义很多类型。 我们十分不建义这样做，当一个工程里有许多声明文件时，它会导致无法处理的命名冲突。</p>\n<p>一个简单的规则是使用库定义的全局变量名来声明命名空间类型。 比如，库定义了一个全局的值cats，你可以这样写</p>\n<p>declare namespace cats {<br>    interface KittySettings { }<br>}<br>不要</p>\n<p>// at top-level<br>interface CatsKittySettings { }<br>这样也保证了库在转换成UMD的时候没有任何的破坏式改变，对于声明文件用户来说。</p>\n<p>ES6模块插件的影响<br>一些插件添加或修改已存在的顶层模块的导出部分。 当然这在CommonJS和其它加载器里是允许的，ES模块被当作是不可改变的因此这种模式就不可行了。 因为TypeScript是能不预知加载器类型的，所以没没在编译时保证，但是开发者如果要转到ES6模块加载器上应该注意这一点。</p>\n<p>ES6模块调用签名的影响<br>很多流行库，比如Express，暴露出自己作为可以调用的函数。 比如，典型的Express使用方法如下：</p>\n<p>import exp = require(“express”);<br>var app = exp();<br>在ES6模块加载器里，顶层的对象（这里以exp导入）只能具有属性； 顶层的模块对象永远不能被调用。 十分常见的解决方法是定义一个default导出到一个可调用的/可构造的对象； 一会模块加载器助手工具能够自己探测到这种情况并且使用default导出来替换顶层对象。</p>\n</script></p>","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:55.082Z","path":"2018/04/02/ts/issus/","text":"1, A maximum of 1 class per file is allowed. (max-classes-per-file)(不允许在同一个文件中定义多个类) SOLUTION： 在tslint中添加规则： “max-classes-per-file”: true, 2，Declaration of public instance field not allowed after declaration of public instance method. Instead, this should come at the beginning of the class/interface. (member-ordering) （方法类型排序限制） SOLUTION： “member-ordering”: [ true, { “order”: [ “public-static-field”, “public-instance-field”, “public-constructor”, “private-static-field”, “private-instance-field”, “private-constructor”, “public-instance-method”, “protected-instance-method”, “private-instance-method” ] }]","raw":"1,\tA maximum of 1 class per file is allowed. (max-classes-per-file)(不允许在同一个文件中定义多个类)\n\nSOLUTION： 在tslint中添加规则： \"max-classes-per-file\": true,\n\n2，Declaration of public instance field not allowed after declaration of public instance method. Instead, this should come at the beginning of the class/interface. (member-ordering) （方法类型排序限制）\n\nSOLUTION： \"member-ordering\": [\n  true,\n  {\n    \"order\": [\n      \"public-static-field\",\n      \"public-instance-field\",\n      \"public-constructor\",\n      \"private-static-field\",\n      \"private-instance-field\",\n      \"private-constructor\",\n      \"public-instance-method\",\n      \"protected-instance-method\",\n      \"private-instance-method\"\n    ]\n  }\n]","content":"<p>1,    A maximum of 1 class per file is allowed. (max-classes-per-file)(不允许在同一个文件中定义多个类)</p>\n<p>SOLUTION： 在tslint中添加规则： “max-classes-per-file”: true,</p>\n<p>2，Declaration of public instance field not allowed after declaration of public instance method. Instead, this should come at the beginning of the class/interface. (member-ordering) （方法类型排序限制）</p>\n<p>SOLUTION： “member-ordering”: [<br>  true,<br>  {<br>    “order”: [<br>      “public-static-field”,<br>      “public-instance-field”,<br>      “public-constructor”,<br>      “private-static-field”,<br>      “private-instance-field”,<br>      “private-constructor”,<br>      “public-instance-method”,<br>      “protected-instance-method”,<br>      “private-instance-method”<br>    ]<br>  }<br>]</p>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:55.050Z","path":"2018/04/02/ts/bascal/","text":"turple: 可以包含不同数据类型的数组 默认情况下，undefined and null 是所有类型的子类型，意味着你可以给任意类型赋值undefined and null. function f({ a, b = 0 } = { a: &quot;&quot; }): void { // ... } f({ a: &quot;yes&quot; }); // ok, default b = 0 f(); // ok, default to {a: &quot;&quot;}, which then defaults b = 0 f({}); // error, &apos;a&apos; is required if you supply an argument 意味着函数f有默认值{a: “”}而b = 0只是给参数的b属性赋默认值，总而言之，你如果要给f传递一个参数，那么参数必须带有a属性 对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法： class C { p = 12; m() { } } let c = new C(); let clone = { ...c }; clone.p; // ok clone.m(); // error! function identity(arg: T): T { return arg; }我们给identity添加了类型变量T。 T帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。 之后我们再次使用了T当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 interface SquareConfig { color?: string; // 不是必须的属性 width?: number; } 一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用readonly来指定只读属性: interface Point { readonly x: number; readonly y: number; } TypeScript具有ReadonlyArray类型，它与Array相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改： let a: number[] = [1, 2, 3, 4]; let ro: ReadonlyArray&lt;number&gt; = a; ro[0] = 12; // error! ro.push(5); // error! ro.length = 100; // error! a = ro; // error! 上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写： a = ro as number[]; readonly vs const最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用const，若做为属性则使用readonly。","raw":"turple:\t可以包含不同数据类型的数组\n\n默认情况下，undefined and null 是所有类型的子类型，意味着你可以给任意类型赋值undefined and null.\n\n    function f({ a, b = 0 } = { a: \"\" }): void {\n    // ...\n    }\n    f({ a: \"yes\" }); // ok, default b = 0\n    f(); // ok, default to {a: \"\"}, which then defaults b = 0\n    f({}); // error, 'a' is required if you supply an argument\n意味着函数f有默认值{a: \"\"}而b = 0只是给参数的b属性赋默认值，总而言之，你如果要给f传递一个参数，那么参数必须带有a属性\n\n对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：\n\n    class C {\n      p = 12;\n      m() {\n      }\n    }\n    let c = new C();\n    let clone = { ...c };\n    clone.p; // ok\n    clone.m(); // error!\n\n\n<code>\n    function identity<T>(arg: T): T {\n       return arg;\n    }\n</code>\n我们给identity添加了类型变量T。 T帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。 之后我们再次使用了T当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。\n\n<p style=\"color: #999;background-color:#EEF0F4;\"><strong>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）</strong>。\n\n泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>\n    \n    interface SquareConfig {\n      color?: string;\t// 不是必须的属性\n      width?: number;\n    }\n\n一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用readonly来指定只读属性:\n   \n\t interface Point {\n    \treadonly x: number;\n    \treadonly y: number;\n    }\n\n\nTypeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：\n\n    let a: number[] = [1, 2, 3, 4];\n    let ro: ReadonlyArray<number> = a;\n    ro[0] = 12; // error!\n    ro.push(5); // error!\n    ro.length = 100; // error!\n    a = ro; // error!\n上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：\n\n    a = ro as number[];\n\n\n**readonly vs const</br>**\n最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用const，若做为属性则使用readonly。","content":"<p>turple:    可以包含不同数据类型的数组</p>\n<p>默认情况下，undefined and null 是所有类型的子类型，意味着你可以给任意类型赋值undefined and null.</p>\n<pre><code>function f({ a, b = 0 } = { a: &quot;&quot; }): void {\n// ...\n}\nf({ a: &quot;yes&quot; }); // ok, default b = 0\nf(); // ok, default to {a: &quot;&quot;}, which then defaults b = 0\nf({}); // error, &apos;a&apos; is required if you supply an argument\n</code></pre><p>意味着函数f有默认值{a: “”}而b = 0只是给参数的b属性赋默认值，总而言之，你如果要给f传递一个参数，那么参数必须带有a属性</p>\n<p>对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：</p>\n<pre><code>class C {\n  p = 12;\n  m() {\n  }\n}\nlet c = new C();\nlet clone = { ...c };\nclone.p; // ok\nclone.m(); // error!\n</code></pre><p><code><br>    function identity<t>(arg: T): T {<br>       return arg;<br>    }<br></t></code><br>我们给identity添加了类型变量T。 T帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。 之后我们再次使用了T当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。</p>\n<p style=\"color: #999;background-color:#EEF0F4;\"><strong>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）</strong>。<br><br>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>\n\n<pre><code>interface SquareConfig {\n  color?: string;    // 不是必须的属性\n  width?: number;\n}\n</code></pre><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用readonly来指定只读属性:</p>\n<pre><code> interface Point {\n    readonly x: number;\n    readonly y: number;\n}\n</code></pre><p>TypeScript具有ReadonlyArray<t>类型，它与Array<t>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</t></t></p>\n<pre><code>let a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray&lt;number&gt; = a;\nro[0] = 12; // error!\nro.push(5); // error!\nro.length = 100; // error!\na = ro; // error!\n</code></pre><p>上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>\n<pre><code>a = ro as number[];\n</code></pre><p><strong>readonly vs const<br></strong><br>最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用const，若做为属性则使用readonly。</p>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:55.031Z","path":"2018/04/02/stylesheets/margin重叠/","text":"���������鼶���ӵĴ�ֱ���ڱ߽���غϡ�����ı߽��������ڱ߽���������ֵ��������ָ��߽磬�����������߽��м�ȥ����ֵ���ĸ��߽硣���û�����߽磬������м�ȥ����ֵ���ĸ��߽硣ע�⣺���ڵĺ��ӿ��ܲ������ɸ��ӹ�ϵ��ͬ����ϵ��Ԫ�����ɡ����Ǳ߽���ص�Ҳ����������� 1��ˮƽ�߾���Զ�����غϡ�2���ڹ淶�ĵ��У�2�������ϵĿ鼶��ģ�����ڵĴ�ֱmargin���ص������յ�marginֵ���㷽�����£�a��ȫ����Ϊ��ֵ��ȡ����ߣ�b����ȫ����ֵ����ȡ����ֵ��Ȼ������ֵ��ȥ���ֵ��c��û����ֵ����ȡ����ֵ��Ȼ����0��ȥ���ֵ��ע�⣺���ڵĺ�ģ�Ϳ�����DOMԪ�ض�̬������û�����ڻ�̳й�ϵ��3�����ڵĺ�ģ���У�������е�һ���Ǹ����ģ�float������ֱmargin�����ص������Ҹ����ĺ�ģ�ͺ�������Ԫ��֮��Ҳ��������4��������overflow���Ե�Ԫ�غ�������Ԫ��֮���margin�����ص���overflowȡֵΪvisible���⣩��5�������˾��Զ�λ��position:absolute���ĺ�ģ�ͣ���ֱmargin���ᱻ�ص������Һ����ǵ���Ԫ��֮��Ҳ��һ����6��������display:inline-block��Ԫ�أ���ֱmargin�����ص������������ǵ���Ԫ��֮��Ҳ��һ����7�����һ����ģ�͵�����margin���ڣ���ʱ����margin�����ص����ǣ�collapse through����������������£�Ԫ�ص�λ�ã�position��ȡ������������Ԫ�ص�margin�Ƿ��ص���a�����Ԫ�ص�margin�����ĸ�Ԫ�ص�margin-top�ص���һ�𣬺�ģ��border-top�ı߽綨������ĸ�Ԫ����ͬ��b�����⣬����Ԫ�صĸ�Ԫ�ز�����margin���ص�������˵ֻ�и�Ԫ�ص�margin-bottom�ǲ������ġ����Ԫ�ص�border-top���㣬��ôԪ�ص�border-top�߽�λ�ú�ԭ��һ����һ��Ӧ�������������Ԫ�ص�margin-top����������Ŀ鼶��Ԫ�ص�margin-bottom�ص���ע�⣬��Щ�Ѿ����ص����ǵ�Ԫ�ص�λ�ö������Ѿ��ص���Ԫ�ص�λ��û���κ�Ӱ�죻ֻ���ڶ���ЩԪ�ص���Ԫ�ض�λʱ��border-top�߽�λ�ò��Ǳ���ġ�8����Ԫ�صĴ�ֱmargin���ᱻ�ص��� ��߾�(margin)�ص�ʾ�� ��߾��ص���ָ������ֱ���ڵĿ鼶Ԫ�أ������������߾�����ʱ������߾������ص��������ص������߾࣬�������нϴ��ߡ�ͼʾ�� ��һ���ص������ǵ�һ��Ԫ�ذ�������һ��Ԫ��֮��ʱ����Ԫ���븸Ԫ��֮��Ҳ������ص������ص������߾࣬������������ߣ�����дͼƬ����CSS ��߾�(margin)�ص�����ֹ����ͬ�����һ�������ݵĿ�Ԫ�أ����������±߾�Ҳ������ص�������дͼƬ����CSS ��߾�(margin)�ص�����ֹ���� ��߾��ص������� ��߾���ص�ֻ��������ͨ���ĵ���������߾�֮�䣬����������е���ֵĹ�����ʵ������ʵ���塣���룬��������������һϵ�й���Ŀ鼶Ԫ�أ������P��ʱ����ô��Ԫ��֮����Ϊ��߾��ص��Ĵ��ڣ�����֮��Ͳ������˫���ľ��롣 ��ֹ��߾��ص���������� ��Ȼ��߾���ص�����һ�������壬����ʱ�������������ȴ������Ԫ��֮������ص�����ô���������¼�������ɹ��ο��� ���Ԫ��padding�����ڲ�Ԫ��͸���߿� border:1px solid transparent;�ڲ�Ԫ�ؾ��Զ�λ postion:absolute:���Ԫ�� overflow:hidden;�ڲ�Ԫ�� ��float:left;��display:inline-block;�ڲ�Ԫ��padding:1px;1234567���Ͻ���ɸ���ʵ���������ȡ��","raw":"���������鼶���ӵĴ�ֱ���ڱ߽���غϡ�����ı߽��������ڱ߽���������ֵ��������ָ��߽磬�����������߽��м�ȥ����ֵ���ĸ��߽硣���û�����߽磬������м�ȥ����ֵ���ĸ��߽硣ע�⣺���ڵĺ��ӿ��ܲ������ɸ��ӹ�ϵ��ͬ����ϵ��Ԫ�����ɡ� \n���Ǳ߽���ص�Ҳ�����������\n\n1��ˮƽ�߾���Զ�����غϡ� \n2���ڹ淶�ĵ��У�2�������ϵĿ鼶��ģ�����ڵĴ�ֱmargin���ص������յ�marginֵ���㷽�����£� \na��ȫ����Ϊ��ֵ��ȡ����ߣ� \nb����ȫ����ֵ����ȡ����ֵ��Ȼ������ֵ��ȥ���ֵ�� \nc��û����ֵ����ȡ����ֵ��Ȼ����0��ȥ���ֵ�� \nע�⣺���ڵĺ�ģ�Ϳ�����DOMԪ�ض�̬������û�����ڻ�̳й�ϵ�� \n3�����ڵĺ�ģ���У�������е�һ���Ǹ����ģ�float������ֱmargin�����ص������Ҹ����ĺ�ģ�ͺ�������Ԫ��֮��Ҳ�������� \n4��������overflow���Ե�Ԫ�غ�������Ԫ��֮���margin�����ص���overflowȡֵΪvisible���⣩�� \n5�������˾��Զ�λ��position:absolute���ĺ�ģ�ͣ���ֱmargin���ᱻ�ص������Һ����ǵ���Ԫ��֮��Ҳ��һ���� \n6��������display:inline-block��Ԫ�أ���ֱmargin�����ص������������ǵ���Ԫ��֮��Ҳ��һ���� \n7�����һ����ģ�͵�����margin���ڣ���ʱ����margin�����ص����ǣ�collapse through����������������£�Ԫ�ص�λ�ã�position��ȡ������������Ԫ�ص�margin�Ƿ��ص��� \na�����Ԫ�ص�margin�����ĸ�Ԫ�ص�margin-top�ص���һ�𣬺�ģ��border-top�ı߽綨������ĸ�Ԫ����ͬ�� \nb�����⣬����Ԫ�صĸ�Ԫ�ز�����margin���ص�������˵ֻ�и�Ԫ�ص�margin-bottom�ǲ������ġ����Ԫ�ص�border-top���㣬��ôԪ�ص�border-top�߽�λ�ú�ԭ��һ���� \nһ��Ӧ�������������Ԫ�ص�margin-top����������Ŀ鼶��Ԫ�ص�margin-bottom�ص��� \nע�⣬��Щ�Ѿ����ص����ǵ�Ԫ�ص�λ�ö������Ѿ��ص���Ԫ�ص�λ��û���κ�Ӱ�죻ֻ���ڶ���ЩԪ�ص���Ԫ�ض�λʱ��border-top�߽�λ�ò��Ǳ���ġ� \n8����Ԫ�صĴ�ֱmargin���ᱻ�ص���\n\n��߾�(margin)�ص�ʾ��\n\n��߾��ص���ָ������ֱ���ڵĿ鼶Ԫ�أ������������߾�����ʱ������߾������ص��������ص������߾࣬�������нϴ��ߡ� \nͼʾ��\n\n��һ���ص������ǵ�һ��Ԫ�ذ�������һ��Ԫ��֮��ʱ����Ԫ���븸Ԫ��֮��Ҳ������ص������ص������߾࣬������������ߣ� \n����дͼƬ���� \nCSS ��߾�(margin)�ص�����ֹ���� \nͬ�����һ�������ݵĿ�Ԫ�أ����������±߾�Ҳ������ص��� \n����дͼƬ���� \nCSS ��߾�(margin)�ص�����ֹ����\n\n��߾��ص�������\n\n��߾���ص�ֻ��������ͨ���ĵ���������߾�֮�䣬����������е���ֵĹ�����ʵ������ʵ���塣���룬��������������һϵ�й���Ŀ鼶Ԫ�أ������P��ʱ����ô��Ԫ��֮����Ϊ��߾��ص��Ĵ��ڣ�����֮��Ͳ������˫���ľ��롣\n\n��ֹ��߾��ص����������\n\n��Ȼ��߾���ص�����һ�������壬����ʱ�������������ȴ������Ԫ��֮������ص�����ô���������¼�������ɹ��ο���\n\n���Ԫ��padding����\n�ڲ�Ԫ��͸���߿� border:1px solid transparent;\n�ڲ�Ԫ�ؾ��Զ�λ postion:absolute:\n���Ԫ�� overflow:hidden;\n�ڲ�Ԫ�� ��float:left;��display:inline-block;\n�ڲ�Ԫ��padding:1px;\n1\n2\n3\n4\n5\n6\n7\n���Ͻ���ɸ���ʵ���������ȡ��","content":"<p>���������鼶���ӵĴ�ֱ���ڱ߽���غϡ�����ı߽��������ڱ߽���������ֵ��������ָ��߽磬�����������߽��м�ȥ����ֵ���ĸ��߽硣���û�����߽磬������м�ȥ����ֵ���ĸ��߽硣ע�⣺���ڵĺ��ӿ��ܲ������ɸ��ӹ�ϵ��ͬ����ϵ��Ԫ�����ɡ�<br>���Ǳ߽���ص�Ҳ�����������</p>\n<p>1��ˮƽ�߾���Զ�����غϡ�<br>2���ڹ淶�ĵ��У�2�������ϵĿ鼶��ģ�����ڵĴ�ֱmargin���ص������յ�marginֵ���㷽�����£�<br>a��ȫ����Ϊ��ֵ��ȡ����ߣ�<br>b����ȫ����ֵ����ȡ����ֵ��Ȼ������ֵ��ȥ���ֵ��<br>c��û����ֵ����ȡ����ֵ��Ȼ����0��ȥ���ֵ��<br>ע�⣺���ڵĺ�ģ�Ϳ�����DOMԪ�ض�̬������û�����ڻ�̳й�ϵ��<br>3�����ڵĺ�ģ���У�������е�һ���Ǹ����ģ�float������ֱmargin�����ص������Ҹ����ĺ�ģ�ͺ�������Ԫ��֮��Ҳ��������<br>4��������overflow���Ե�Ԫ�غ�������Ԫ��֮���margin�����ص���overflowȡֵΪvisible���⣩��<br>5�������˾��Զ�λ��position:absolute���ĺ�ģ�ͣ���ֱmargin���ᱻ�ص������Һ����ǵ���Ԫ��֮��Ҳ��һ����<br>6��������display:inline-block��Ԫ�أ���ֱmargin�����ص������������ǵ���Ԫ��֮��Ҳ��һ����<br>7�����һ����ģ�͵�����margin���ڣ���ʱ����margin�����ص����ǣ�collapse through����������������£�Ԫ�ص�λ�ã�position��ȡ������������Ԫ�ص�margin�Ƿ��ص���<br>a�����Ԫ�ص�margin�����ĸ�Ԫ�ص�margin-top�ص���һ�𣬺�ģ��border-top�ı߽綨������ĸ�Ԫ����ͬ��<br>b�����⣬����Ԫ�صĸ�Ԫ�ز�����margin���ص�������˵ֻ�и�Ԫ�ص�margin-bottom�ǲ������ġ����Ԫ�ص�border-top���㣬��ôԪ�ص�border-top�߽�λ�ú�ԭ��һ����<br>һ��Ӧ�������������Ԫ�ص�margin-top����������Ŀ鼶��Ԫ�ص�margin-bottom�ص���<br>ע�⣬��Щ�Ѿ����ص����ǵ�Ԫ�ص�λ�ö������Ѿ��ص���Ԫ�ص�λ��û���κ�Ӱ�죻ֻ���ڶ���ЩԪ�ص���Ԫ�ض�λʱ��border-top�߽�λ�ò��Ǳ���ġ�<br>8����Ԫ�صĴ�ֱmargin���ᱻ�ص���</p>\n<p>��߾�(margin)�ص�ʾ��</p>\n<p>��߾��ص���ָ������ֱ���ڵĿ鼶Ԫ�أ������������߾�����ʱ������߾������ص��������ص������߾࣬�������нϴ��ߡ�<br>ͼʾ��</p>\n<p>��һ���ص������ǵ�һ��Ԫ�ذ�������һ��Ԫ��֮��ʱ����Ԫ���븸Ԫ��֮��Ҳ������ص������ص������߾࣬������������ߣ�<br>����дͼƬ����<br>CSS ��߾�(margin)�ص�����ֹ����<br>ͬ�����һ�������ݵĿ�Ԫ�أ����������±߾�Ҳ������ص���<br>����дͼƬ����<br>CSS ��߾�(margin)�ص�����ֹ����</p>\n<p>��߾��ص�������</p>\n<p>��߾���ص�ֻ��������ͨ���ĵ���������߾�֮�䣬����������е���ֵĹ�����ʵ������ʵ���塣���룬��������������һϵ�й���Ŀ鼶Ԫ�أ������P��ʱ����ô��Ԫ��֮����Ϊ��߾��ص��Ĵ��ڣ�����֮��Ͳ������˫���ľ��롣</p>\n<p>��ֹ��߾��ص����������</p>\n<p>��Ȼ��߾���ص�����һ�������壬����ʱ�������������ȴ������Ԫ��֮������ص�����ô���������¼�������ɹ��ο���</p>\n<p>���Ԫ��padding����<br>�ڲ�Ԫ��͸���߿� border:1px solid transparent;<br>�ڲ�Ԫ�ؾ��Զ�λ postion:absolute:<br>���Ԫ�� overflow:hidden;<br>�ڲ�Ԫ�� ��float:left;��display:inline-block;<br>�ڲ�Ԫ��padding:1px;<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>���Ͻ���ɸ���ʵ���������ȡ��</p>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:55.018Z","path":"2018/04/02/react/router/","text":"for browser environment we can use react-router-dom, manage dynamic request, for static website History every router will create a history object and for search current location,it will rerender website when it changes.this history obj promise react router provides othercomponent’s reusability, so other components must render in router. if a react router component retrospectto parent but can’t find router component, this componentwill not working. router路由器组建无法接受两个及以上的子元素。基于这种操作的restrict，创建一个组建来渲染应用其余部分是一个有效地方法对于服务端渲染，将应用从router组件中分离也是重要的。","raw":"for browser environment we can use react-router-dom,\n<BrowserRouter> manage dynamic request,\n<HashRouter> for static website\n\n**History**\n\nevery router will create a history object and for search current location,it will rerender website when it changes.\nthis history obj promise react router provides other\ncomponent's reusability, so other components must render in router. if a react router component retrospect \nto parent but can't find router component, this component\nwill not working.\n\n**router**\n路由器组建无法接受两个及以上的子元素。基于这种操作的restrict，\n创建一个<App>组建来渲染应用其余部分是一个有效地方法\n对于服务端渲染，将应用从router组件中分离也是重要的。\n\n\n","content":"<p>for browser environment we can use react-router-dom,</p>\n<p><browserrouter> manage dynamic request,</browserrouter></p>\n<p><hashrouter> for static website</hashrouter></p>\n<p><strong>History</strong></p>\n<p>every router will create a history object and for search current location,it will rerender website when it changes.<br>this history obj promise react router provides other<br>component’s reusability, so other components must render in router. if a react router component retrospect<br>to parent but can’t find router component, this component<br>will not working.</p>\n<p><strong>router</strong><br>路由器组建无法接受两个及以上的子元素。基于这种操作的restrict，<br>创建一个<app>组建来渲染应用其余部分是一个有效地方法<br>对于服务端渲染，将应用从router组件中分离也是重要的。</app></p>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:55.016Z","path":"2018/04/02/react/notice/","text":"在es6中，类里面的方法，不允许直接使用this来指代实例去使用属性 你必须在构造函数中bind this或者使用箭头函数来代替函数声明，或者再调用时绑定this 或者你可以声明一个全局变量，在构造函数中将this赋值给这个全局变量","raw":"在es6中，类里面的方法，不允许直接使用this来指代实例去使用属性\n\n你必须在构造函数中bind this或者使用箭头函数来代替函数声明，或者再调用时绑定this\n\n或者你可以声明一个全局变量，在构造函数中将this赋值给这个全局变量","content":"<p>在es6中，类里面的方法，不允许直接使用this来指代实例去使用属性</p>\n<p>你必须在构造函数中bind this或者使用箭头函数来代替函数声明，或者再调用时绑定this</p>\n<p>或者你可以声明一个全局变量，在构造函数中将this赋值给这个全局变量</p>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:55.010Z","path":"2018/04/02/react/dom/","text":"react可以允许我们通过 ref 来定位一个组件。具体的做法是：先给一个组件设置一个 ref=‘xxx’ 的属性，注意这个ref必须是全局唯一的。 然后就可以通过 this.refs.city 来访问这个组件。但是请注意，这里拿到的只是虚拟DOM，而不是真实的DOM。只有在render方法执行之后，并且react已经完成了DOM的更新，才能通过 this.refs.city.getDOMNode() 来拿到原生的DOM元素。 作者：隔壁陈叔叔链接：https://www.jianshu.com/p/c401e417bd8a來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","raw":"react可以允许我们通过 ref 来定位一个组件。具体的做法是：\n先给一个组件设置一个 ref=‘xxx’ 的属性，注意这个ref必须是全局唯一的。\n\n<input ref=‘city’ />\n然后就可以通过 this.refs.city 来访问这个组件。\n但是请注意，这里拿到的只是虚拟DOM，而不是真实的DOM。\n只有在render方法执行之后，并且react已经完成了DOM的更新，才能通过 this.refs.city.getDOMNode() 来拿到原生的DOM元素。\n\n作者：隔壁陈叔叔\n链接：https://www.jianshu.com/p/c401e417bd8a\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","content":"<p>react可以允许我们通过 ref 来定位一个组件。具体的做法是：<br>先给一个组件设置一个 ref=‘xxx’ 的属性，注意这个ref必须是全局唯一的。</p>\n<p><input ref=\"‘city’\"><br>然后就可以通过 this.refs.city 来访问这个组件。<br>但是请注意，这里拿到的只是虚拟DOM，而不是真实的DOM。<br>只有在render方法执行之后，并且react已经完成了DOM的更新，才能通过 this.refs.city.getDOMNode() 来拿到原生的DOM元素。</p>\n<p>作者：隔壁陈叔叔<br>链接：<a href=\"https://www.jianshu.com/p/c401e417bd8a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/c401e417bd8a</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n","comments":true,"categories":[],"tags":[]},{"title":"react props state","date":"2018-04-02T15:27:54.978Z","path":"2018/04/02/react/begin/","text":"组件和props 组件让你按需分割界面，可重用的块，思考将这些快分割； 组件的概念就像js中的函数，它们可以接受任意的参数（称为props）返回应该显示的react元素 这个简单的方式定义了一个组件，使用js的函数function Welcome(props) { return Hello, {props.name};}这个函数是一个有效的react组件，因为他接受了一个单一的props（标准的properties）数据对象参数并且返回一个react元素。我们称这样的组件为functional，因为他是字面上的js函数？ 渲染组件 我们可以定义一个react元素代表传统的标签 const ele = ; 元素也可以代表用户自定义的组件 当react看见一个代表用户自定义组件的元素时，它会传入JSX属性到这个组件作为一个单一的对象，我们成这样的对象为props ex： function Welcome(props) { return Hello, {props.name}; } const element = &lt;Welcome name=&quot;Sara&quot; /&gt;; ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); 他将会输出Hello, Sara 让我们总结一下在这个例子中方式发生了什么： 1，我们在React.Dom中使用了元素 2，react将{name: “Sara”}作为props传给Welcome组件 3，我们的Welcome组件返回Hello Sara结果 4，react dom匹配Hello Sara有效地更新DOM 注：自定义组件首字母必须大写当一个元素以一个小写的字母开始，它指向一个内建的组件，像 或者 结果将会是一个字符串’div’ 或者 ‘span’,然后传给React.creactEalement，类型以一个大写字母开始，像，编译结果会是React.createElement(Foo),就爱那个会正确的返回一个定义的组件，或者从你的js文件中引入 Composing Compoents(晓不得咋个翻译额，直接引用原文还更容易理解)Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components. For example, we can create an App component that renders Welcome many times: function Welcome(props) { return Hello, {props.name};} function App() { return ( );} ReactDOM.render( , document.getElementById(‘root’)); Extracting ComponentsDon’t be afraid to split components into smaller components. For example, consider this Comment component: function Comment(props) { return ( {props.author.name} {props.text} {formatDate(props.date)} );} 它接收auther，text，和date作为props，描述可一个在社交媒体网站上的评论组件 改变这个组件可能会变得很棘手，因为它含有很多层的嵌套，而且它也很难复用在其他的parts。让我们从他上面分割一些组件下来。 首先我们分割头像组件 function Avatar(props) { return ( );} 头像组件并不需要知道他是要在一个组件内渲染，这也是为什么我们给一个更为广泛的name: user而不是author作为props 我们建议在组件中的name props在视图中有自己的重点，而不是考虑在上下文中它的使用 现在我们可以使用更小一点的组件function Comment(props) { return ( {props.author.name} {props.text} {formatDate(props.date)} );} 接下来我们分割一个userInfo 组件渲染Avatar接下来是user‘s namefunction UserInfo(props) { return ( {props.user.name} );} 这让我们简单的组件更进一步function Comment(props) { return ( {props.text} {formatDate(props.date)} );} 组件分割也许在刚开始看起来像grunt的工作，但是有一个palette装了复用组件可以在大型app中使用。一个简单的规则是如果你的一部分UI使用了几次(Button, Panel, Avatar)，或者它自己足够复杂（App, FeedStory, Comment），这是一个好的复用组件的标准 props和只读 无论你是否使用function or class定义组件，他必须不能够被修改它自己的props，考虑这个求和函数function sum(a, b) { return a + b;} 像这样的函数被叫做“pure”，因为他们并不会试图去修改他们的输入，而且当输入相同时总是返回相同的结果。 作为对比，这个函数不是“pure”的，因为它会改变它自己的输入 react是很灵活的，但是他有一个单一的严格规则： 所有的组件都必须像pure函数以尊重他们的props state and Lifecycle 到目前为止我们学习了如何更新UI 我们使用ReactDOM.render()来改变渲染的输出 function tick() { const element = ( Hello, world! It is {new Date().toLocaleTimeString()}. ); ReactDOM.render( element, document.getElementById(‘root’) );} setInterval(tick, 1000); 在这一章中，我们将会学习如何制作一个时钟组件，他是复用的而且封装性的，它会建立自己的计数器且每秒都会更新 我们先封装一下他是什么样的 function Clock(props) { return ( Hello, world! It is {props.date.toLocaleTimeString()}. );} function tick() { ReactDOM.render( , document.getElementById(‘root’) );} setInterval(tick, 1000); 无论怎样，它却少了一个关键的需求：事实上Clock建立一个计时器且每秒自动更新UI应该是一个细节上的实现。 理想情况下我们想只写一次然后它自己更新：ReactDOM.render( , document.getElementById(‘root’)); 为了实现这个，我们需要向组件中添加“state”， state比props更小，但是他是私有的，而且组件对他有完全控制权 我们曾经注意到组件作为类被定义时有一些传统的特性，本地的state正是如此： 一个只能被类使用的变量 简单概括：Converting a Function to a ClassYou can convert a functional component like Clock to a class in five steps: Create an ES6 class, with the same name, that extends React.Component. Add a single empty method to it called render(). Move the body of the function into the render() method. Replace props with this.props in the render() body. Delete the remaining empty function declaration. class Clock extends React.Component { render() { return ( Hello, world! It is {this.props.date.toLocaleTimeString()}. ); }} 现在clock组件作为类被定义，而不是函数 这使得我们可以使用附加的局部state和生命周期特性 Adding Local State to a Class 我们将会使用三个步骤从props中移除date到state中：1，在render()函数中使用this.state.date替换this.props.date,class Clock extends React.Component { render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); }}2, 添加一个类的构造器并给this.state初始化class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); }}注意我们是如何传入props到父构造器中的 类组件应该总是向父组件传入props 在元素中移除移除dete propsReactDOM.render( , document.getElementById(‘root’)); The result looks like this: class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); }} ReactDOM.render( , document.getElementById(‘root’)); Adding Lifecycle Methods to a Class In applications with many components, it’s very important to free up resources taken by the components when they are destroyed. We want to set up a timer whenever the Clock is rendered to the DOM for the first time. This is called “mounting” in React. We also want to clear that timer whenever the DOM produced by the Clock is removed. This is called “unmounting” in React. We can declare special methods on the component class to run some code when a component mounts and unmounts: class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } componentDidMount() { } componentWillUnmount() { } render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); }}These methods are called “lifecycle hooks”. The componentDidMount() hook runs after the component output has been rendered to the DOM. This is a good place to set up a timer: componentDidMount() { this.timerID = setInterval( () =&gt; this.tick(), 1000 ); } 注意到我们是将timeID保存到this上的 当this.props被react建立且this.state有一个特俗的意义，如果你需要存储一些不会显示在试图中的数据可以自由的手动添加字段到类中 不在render中使用的数据也不应该出现在state中 我们将会拆除计时器当componentWillUnmount被触发时， componentWillUnmount() { clearInterval(this.timerID); } 最终我们会实现一个叫做tick的方法，这个方法让组件每秒更新一次 他将会使用this.setState()指定组件的局部state更新 class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } componentDidMount() { this.timerID = setInterval( () =&gt; this.tick(), 1000 ); } componentWillUnmount() { clearInterval(this.timerID); } tick() { this.setState({ date: new Date() }); } render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); }} ReactDOM.render( , document.getElementById(‘root’)); 现在它能够正常工作了 让我们简单总结一下是怎么回事并排序事件的触发顺序 1，当组件被传入ReactDOM.render()时，react触发了Clock组件的构造函数，自从Clock需要显示当前事件，他使用一个包含时间的对象初始化this.state，我们将会在接下来更新他。2，接着react使用了组件的render函数，这让react了解到那些数据应该在屏幕上显示，react下一步会匹配render的输出更新dom3，当Clock的输出被内嵌到dom中，react触发componentDidMount函数，再此函数中Clock要求浏览器建立一个计时器每秒呼叫组件的tick方法4，浏览器每秒呼叫tick函数，在函数中Clock计划使用setState改变当前时间去更新视图，感谢setState，react才能知道state被改变，接着使用render函数去更新那些应该在屏幕上显示的数据，这时，this.state.date将会不同于render函数中的数据，所以render函数的输出将会更新时间。5，如果组件一旦从dom中移除，react将会运行componentWillUnmount函数，所以这个计时器也被停止 事件处理","raw":"---\ntitle: react props state\ndate: 2018年4月03日13:15:08\ncategories: react\ntags: [react]\ndescription: react基础\n---\n\n组件和props\n\n组件让你按需分割界面，可重用的块，思考将这些快分割；\n\n组件的概念就像js中的函数，它们可以接受任意的参数（称为props）返回应该显示的react元素\n\n这个简单的方式定义了一个组件，使用js的函数\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n这个函数是一个有效的react组件，因为他接受了一个单一的props（标准的properties）数据对象参数并且返回一个react元素。\n我们称这样的组件为functional，因为他是字面上的js函数？\n\n**渲染组件**\n\n我们可以定义一个react元素代表传统的标签\n\nconst ele = <div />;\n\n元素也可以代表用户自定义的组件\n\n当react看见一个代表用户自定义组件的元素时，它会传入JSX属性到这个组件作为一个单一的对象，我们成这样的对象为props\n\nex：\n    function Welcome(props) {\n      return <h1>Hello, {props.name}</h1>;\n    }\n    \n    const element = <Welcome name=\"Sara\" />;\n    ReactDOM.render(\n      element,\n      document.getElementById('root')\n    );\n\n他将会输出<h1>Hello, Sara</h1>\n\n让我们总结一下在这个例子中方式发生了什么：\n- 1，我们在React.Dom中使用了<welcome name=\"Sara\">元素\n- 2，react将{name: \"Sara\"}作为props传给Welcome组件\n- 3，我们的Welcome组件返回<h1>Hello Sara</h1>结果\n- 4，react dom匹配<h1>Hello Sara</h1>有效地更新DOM\n\n注：自定义组件首字母必须大写\n<small>当一个元素以一个小写的字母开始，它指向一个内建的组件，像<div> 或者 <span> 结果将会是一个字符串'div' 或者 'span',然后传给React.creactEalement，类型以一个大写字母开始，像<Foo />，编译结果会是React.createElement(Foo),就爱那个会正确的返回一个定义的组件，或者从你的js文件中引入</small>\n\nComposing Compoents(晓不得咋个翻译额，直接引用原文还更容易理解)\nComponents can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components.\n\nFor example, we can create an App component that renders Welcome many times:\n\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n\nfunction App() {\n  return (\n    <div>\n      <Welcome name=\"Sara\" />\n      <Welcome name=\"Cahal\" />\n      <Welcome name=\"Edite\" />\n    </div>\n  );\n}\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\nExtracting Components\nDon’t be afraid to split components into smaller components.\n\nFor example, consider this Comment component:\n\nfunction Comment(props) {\n  return (\n    <div className=\"Comment\">\n      <div className=\"UserInfo\">\n        <img className=\"Avatar\"\n          src={props.author.avatarUrl}\n          alt={props.author.name}\n        />\n        <div className=\"UserInfo-name\">\n          {props.author.name}\n        </div>\n      </div>\n      <div className=\"Comment-text\">\n        {props.text}\n      </div>\n      <div className=\"Comment-date\">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n\n它接收auther，text，和date作为props，描述可一个在社交媒体网站上的评论组件\n\n改变这个组件可能会变得很棘手，因为它含有很多层的嵌套，而且它也很难复用在其他的parts。让我们从他上面分割一些组件下来。\n\n首先我们分割头像组件\n\nfunction Avatar(props) {\n  return (\n    <img className=\"Avatar\"\n      src={props.user.avatarUrl}\n      alt={props.user.name}\n    />\n\n  );\n}\n\n头像组件并不需要知道他是要在一个组件内渲染，这也是为什么我们给一个更为广泛的name: user而不是author作为props\n\n我们建议在组件中的name props在视图中有自己的重点，而不是考虑在上下文中它的使用\n\n现在我们可以使用更小一点的组件\nfunction Comment(props) {\n  return (\n    <div className=\"Comment\">\n      <div className=\"UserInfo\">\n        <Avatar user={props.author} />\n        <div className=\"UserInfo-name\">\n          {props.author.name}\n        </div>\n      </div>\n      <div className=\"Comment-text\">\n        {props.text}\n      </div>\n      <div className=\"Comment-date\">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n\n接下来我们分割一个userInfo\n\n组件渲染Avatar接下来是user‘s name\nfunction UserInfo(props) {\n  return (\n    <div className=\"UserInfo\">\n      <Avatar user={props.user} />\n      <div className=\"UserInfo-name\">\n        {props.user.name}\n      </div>\n    </div>\n  );\n}\n\n这让我们简单的组件更进一步\nfunction Comment(props) {\n  return (\n    <div className=\"Comment\">\n      <UserInfo user={props.author} />\n      <div className=\"Comment-text\">\n        {props.text}\n      </div>\n      <div className=\"Comment-date\">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n\n组件分割也许在刚开始看起来像grunt的工作，但是有一个palette装了复用组件可以在大型app中使用。一个简单的规则是如果你的一部分UI使用了几次(Button, Panel, Avatar)，或者它自己足够复杂（App, FeedStory, Comment），这是一个好的复用组件的标准\n\nprops和只读\n\n无论你是否使用function or class定义组件，他必须不能够被修改它自己的props，考虑这个求和函数\nfunction sum(a, b) {\n  return a + b;\n}\n\n像这样的函数被叫做“pure”，因为他们并不会试图去修改他们的输入，而且当输入相同时总是返回相同的结果。\n\n作为对比，这个函数不是“pure”的，因为它会改变它自己的输入\n\nreact是很灵活的，但是他有一个单一的严格规则：\n\n所有的组件都必须像pure函数以尊重他们的props\n\n\n**state and Lifecycle**\n\n到目前为止我们学习了如何更新UI\n\n我们使用ReactDOM.render()来改变渲染的输出\n\nfunction tick() {\n  const element = (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {new Date().toLocaleTimeString()}.</h2>\n    </div>\n  );\n  ReactDOM.render(\n    element,\n    document.getElementById('root')\n  );\n}\n\nsetInterval(tick, 1000);\n\n在这一章中，我们将会学习如何制作一个时钟组件，他是复用的而且封装性的，它会建立自己的计数器且每秒都会更新\n\n我们先封装一下他是什么样的\n\nfunction Clock(props) {\n  return (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {props.date.toLocaleTimeString()}.</h2>\n    </div>\n  );\n}\n\nfunction tick() {\n  ReactDOM.render(\n    <Clock date={new Date()} />,\n    document.getElementById('root')\n  );\n}\n\nsetInterval(tick, 1000);\n\n无论怎样，它却少了一个关键的需求：事实上Clock建立一个计时器且每秒自动更新UI应该是一个细节上的实现。\n\n理想情况下我们想只写一次然后它自己更新：\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n\n为了实现这个，我们需要向组件中添加“state”，\n\nstate比props更小，但是他是私有的，而且组件对他有完全控制权\n\n我们曾经注意到组件作为类被定义时有一些传统的特性，本地的state正是如此： 一个只能被类使用的变量\n\n简单概括：Converting a Function to a Class\nYou can convert a functional component like Clock to a class in five steps:\n\nCreate an ES6 class, with the same name, that extends React.Component.\n\nAdd a single empty method to it called render().\n\nMove the body of the function into the render() method.\n\nReplace props with this.props in the render() body.\n\nDelete the remaining empty function declaration.\n\nclass Clock extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.props.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\n现在clock组件作为类被定义，而不是函数\n\n这使得我们可以使用附加的局部state和生命周期特性\n\n\n**Adding Local State to a Class**\n\n我们将会使用三个步骤从props中移除date到state中：\n1，在render()函数中使用this.state.date替换this.props.date,\nclass Clock extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n2, 添加一个类的构造器并给this.state初始化\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n注意我们是如何传入props到父构造器中的\n\n\n类组件应该总是向父组件传入props\n\n在<Clock />元素中移除移除dete props\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n\nThe result looks like this:\n\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n\n**Adding Lifecycle Methods to a Class**\n\nIn applications with many components, it’s very important to free up resources taken by the components when they are destroyed.\n\nWe want to set up a timer whenever the Clock is rendered to the DOM for the first time. This is called “mounting” in React.\n\nWe also want to clear that timer whenever the DOM produced by the Clock is removed. This is called “unmounting” in React.\n\nWe can declare special methods on the component class to run some code when a component mounts and unmounts:\n\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  componentDidMount() {\n\n  }\n\n  componentWillUnmount() {\n\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\nThese methods are called “lifecycle hooks”.\n\nThe componentDidMount() hook runs after the component output has been rendered to the DOM. This is a good place to set up a timer:\n\n  componentDidMount() {\n    this.timerID = setInterval(\n      () => this.tick(),\n      1000\n    );\n  }\n\n注意到我们是将timeID保存到this上的\n\n当this.props被react建立且this.state有一个特俗的意义，如果你需要存储一些不会显示在试图中的数据可以自由的手动添加字段到类中\n\n不在render中使用的数据也不应该出现在state中\n\n我们将会拆除计时器当componentWillUnmount被触发时，\n componentWillUnmount() {\n    clearInterval(this.timerID);\n  }\n\n最终我们会实现一个叫做tick的方法，这个方法让组件每秒更新一次\n\n他将会使用this.setState()指定组件的局部state更新\n\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  componentDidMount() {\n    this.timerID = setInterval(\n      () => this.tick(),\n      1000\n    );\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timerID);\n  }\n\n  tick() {\n    this.setState({\n      date: new Date()\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n\n现在它能够正常工作了\n\n让我们简单总结一下是怎么回事并排序事件的触发顺序\n\n1，当<Clock />组件被传入ReactDOM.render()时，react触发了Clock组件的构造函数，自从Clock需要显示当前事件，他使用一个包含时间的对象初始化this.state，我们将会在接下来更新他。\n2，接着react使用了组件的render函数，这让react了解到那些数据应该在屏幕上显示，react下一步会匹配render的输出更新dom\n3，当Clock的输出被内嵌到dom中，react触发componentDidMount函数，再此函数中Clock要求浏览器建立一个计时器每秒呼叫组件的tick方法\n4，浏览器每秒呼叫tick函数，在函数中Clock计划使用setState改变当前时间去更新视图，感谢setState，react才能知道state被改变，接着使用render函数去更新那些应该在屏幕上显示的数据，这时，this.state.date将会不同于render函数中的数据，所以render函数的输出将会更新时间。\n5，如果组件一旦从dom中移除，react将会运行componentWillUnmount函数，所以这个计时器也被停止\n\n\n事件处理\n","content":"<p>组件和props</p>\n<p>组件让你按需分割界面，可重用的块，思考将这些快分割；</p>\n<p>组件的概念就像js中的函数，它们可以接受任意的参数（称为props）返回应该显示的react元素</p>\n<p>这个简单的方式定义了一个组件，使用js的函数<br>function Welcome(props) {<br>  return </p><h1>Hello, {props.name}</h1>;<br>}<br>这个函数是一个有效的react组件，因为他接受了一个单一的props（标准的properties）数据对象参数并且返回一个react元素。<br>我们称这样的组件为functional，因为他是字面上的js函数？<p></p>\n<p><strong>渲染组件</strong></p>\n<p>我们可以定义一个react元素代表传统的标签</p>\n<p>const ele = <div>;</div></p>\n<p>元素也可以代表用户自定义的组件</p>\n<p>当react看见一个代表用户自定义组件的元素时，它会传入JSX属性到这个组件作为一个单一的对象，我们成这样的对象为props</p>\n<p>ex：<br>    function Welcome(props) {<br>      return </p><h1>Hello, {props.name}</h1>;<br>    }<p></p>\n<pre><code>const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;\nReactDOM.render(\n  element,\n  document.getElementById(&apos;root&apos;)\n);\n</code></pre><p>他将会输出</p><h1>Hello, Sara</h1><p></p>\n<p>让我们总结一下在这个例子中方式发生了什么：</p>\n<ul>\n<li>1，我们在React.Dom中使用了<welcome name=\"Sara\">元素</welcome></li>\n<li>2，react将{name: “Sara”}作为props传给Welcome组件</li>\n<li>3，我们的Welcome组件返回<h1>Hello Sara</h1>结果</li>\n<li>4，react dom匹配<h1>Hello Sara</h1>有效地更新DOM</li>\n</ul>\n<p>注：自定义组件首字母必须大写<br><small>当一个元素以一个小写的字母开始，它指向一个内建的组件，像<div> 或者 <span> 结果将会是一个字符串’div’ 或者 ‘span’,然后传给React.creactEalement，类型以一个大写字母开始，像<foo>，编译结果会是React.createElement(Foo),就爱那个会正确的返回一个定义的组件，或者从你的js文件中引入</foo></span></div></small></p>\n<p>Composing Compoents(晓不得咋个翻译额，直接引用原文还更容易理解)<br>Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components.</p>\n<p>For example, we can create an App component that renders Welcome many times:</p>\n<p>function Welcome(props) {<br>  return </p><h1>Hello, {props.name}</h1>;<br>}<p></p>\n<p>function App() {<br>  return (<br>    <div><br>      <welcome name=\"Sara\"><br>      <welcome name=\"Cahal\"><br>      <welcome name=\"Edite\"><br>    </welcome></welcome></welcome></div><br>  );<br>}</p>\n<p>ReactDOM.render(<br>  <app>,<br>  document.getElementById(‘root’)<br>);</app></p>\n<p>Extracting Components<br>Don’t be afraid to split components into smaller components.</p>\n<p>For example, consider this Comment component:</p>\n<p>function Comment(props) {<br>  return (<br>    <div classname=\"Comment\"><br>      <div classname=\"UserInfo\"><br>        <img classname=\"Avatar\" src=\"{props.author.avatarUrl}\" alt=\"{props.author.name}\"><br>        <div classname=\"UserInfo-name\"><br>          {props.author.name}<br>        </div><br>      </div><br>      <div classname=\"Comment-text\"><br>        {props.text}<br>      </div><br>      <div classname=\"Comment-date\"><br>        {formatDate(props.date)}<br>      </div><br>    </div><br>  );<br>}</p>\n<p>它接收auther，text，和date作为props，描述可一个在社交媒体网站上的评论组件</p>\n<p>改变这个组件可能会变得很棘手，因为它含有很多层的嵌套，而且它也很难复用在其他的parts。让我们从他上面分割一些组件下来。</p>\n<p>首先我们分割头像组件</p>\n<p>function Avatar(props) {<br>  return (<br>    <img classname=\"Avatar\" src=\"{props.user.avatarUrl}\" alt=\"{props.user.name}\"></p>\n<p>  );<br>}</p>\n<p>头像组件并不需要知道他是要在一个组件内渲染，这也是为什么我们给一个更为广泛的name: user而不是author作为props</p>\n<p>我们建议在组件中的name props在视图中有自己的重点，而不是考虑在上下文中它的使用</p>\n<p>现在我们可以使用更小一点的组件<br>function Comment(props) {<br>  return (<br>    <div classname=\"Comment\"><br>      <div classname=\"UserInfo\"><br>        <avatar user=\"{props.author}\"><br>        <div classname=\"UserInfo-name\"><br>          {props.author.name}<br>        </div><br>      </avatar></div><br>      <div classname=\"Comment-text\"><br>        {props.text}<br>      </div><br>      <div classname=\"Comment-date\"><br>        {formatDate(props.date)}<br>      </div><br>    </div><br>  );<br>}</p>\n<p>接下来我们分割一个userInfo</p>\n<p>组件渲染Avatar接下来是user‘s name<br>function UserInfo(props) {<br>  return (<br>    <div classname=\"UserInfo\"><br>      <avatar user=\"{props.user}\"><br>      <div classname=\"UserInfo-name\"><br>        {props.user.name}<br>      </div><br>    </avatar></div><br>  );<br>}</p>\n<p>这让我们简单的组件更进一步<br>function Comment(props) {<br>  return (<br>    <div classname=\"Comment\"><br>      <userinfo user=\"{props.author}\"><br>      <div classname=\"Comment-text\"><br>        {props.text}<br>      </div><br>      <div classname=\"Comment-date\"><br>        {formatDate(props.date)}<br>      </div><br>    </userinfo></div><br>  );<br>}</p>\n<p>组件分割也许在刚开始看起来像grunt的工作，但是有一个palette装了复用组件可以在大型app中使用。一个简单的规则是如果你的一部分UI使用了几次(Button, Panel, Avatar)，或者它自己足够复杂（App, FeedStory, Comment），这是一个好的复用组件的标准</p>\n<p>props和只读</p>\n<p>无论你是否使用function or class定义组件，他必须不能够被修改它自己的props，考虑这个求和函数<br>function sum(a, b) {<br>  return a + b;<br>}</p>\n<p>像这样的函数被叫做“pure”，因为他们并不会试图去修改他们的输入，而且当输入相同时总是返回相同的结果。</p>\n<p>作为对比，这个函数不是“pure”的，因为它会改变它自己的输入</p>\n<p>react是很灵活的，但是他有一个单一的严格规则：</p>\n<p>所有的组件都必须像pure函数以尊重他们的props</p>\n<p><strong>state and Lifecycle</strong></p>\n<p>到目前为止我们学习了如何更新UI</p>\n<p>我们使用ReactDOM.render()来改变渲染的输出</p>\n<p>function tick() {<br>  const element = (<br>    <div><br>      <h1>Hello, world!</h1><br>      <h2>It is {new Date().toLocaleTimeString()}.</h2><br>    </div><br>  );<br>  ReactDOM.render(<br>    element,<br>    document.getElementById(‘root’)<br>  );<br>}</p>\n<p>setInterval(tick, 1000);</p>\n<p>在这一章中，我们将会学习如何制作一个时钟组件，他是复用的而且封装性的，它会建立自己的计数器且每秒都会更新</p>\n<p>我们先封装一下他是什么样的</p>\n<p>function Clock(props) {<br>  return (<br>    <div><br>      <h1>Hello, world!</h1><br>      <h2>It is {props.date.toLocaleTimeString()}.</h2><br>    </div><br>  );<br>}</p>\n<p>function tick() {<br>  ReactDOM.render(<br>    <clock date=\"{new\" date()}=\"\">,<br>    document.getElementById(‘root’)<br>  );<br>}</clock></p>\n<p>setInterval(tick, 1000);</p>\n<p>无论怎样，它却少了一个关键的需求：事实上Clock建立一个计时器且每秒自动更新UI应该是一个细节上的实现。</p>\n<p>理想情况下我们想只写一次然后它自己更新：<br>ReactDOM.render(<br>  <clock>,<br>  document.getElementById(‘root’)<br>);</clock></p>\n<p>为了实现这个，我们需要向组件中添加“state”，</p>\n<p>state比props更小，但是他是私有的，而且组件对他有完全控制权</p>\n<p>我们曾经注意到组件作为类被定义时有一些传统的特性，本地的state正是如此： 一个只能被类使用的变量</p>\n<p>简单概括：Converting a Function to a Class<br>You can convert a functional component like Clock to a class in five steps:</p>\n<p>Create an ES6 class, with the same name, that extends React.Component.</p>\n<p>Add a single empty method to it called render().</p>\n<p>Move the body of the function into the render() method.</p>\n<p>Replace props with this.props in the render() body.</p>\n<p>Delete the remaining empty function declaration.</p>\n<p>class Clock extends React.Component {<br>  render() {<br>    return (<br>      <div><br>        <h1>Hello, world!</h1><br>        <h2>It is {this.props.date.toLocaleTimeString()}.</h2><br>      </div><br>    );<br>  }<br>}</p>\n<p>现在clock组件作为类被定义，而不是函数</p>\n<p>这使得我们可以使用附加的局部state和生命周期特性</p>\n<p><strong>Adding Local State to a Class</strong></p>\n<p>我们将会使用三个步骤从props中移除date到state中：<br>1，在render()函数中使用this.state.date替换this.props.date,<br>class Clock extends React.Component {<br>  render() {<br>    return (<br>      <div><br>        <h1>Hello, world!</h1><br>        <h2>It is {this.state.date.toLocaleTimeString()}.</h2><br>      </div><br>    );<br>  }<br>}<br>2, 添加一个类的构造器并给this.state初始化<br>class Clock extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {date: new Date()};<br>  }</p>\n<p>  render() {<br>    return (<br>      <div><br>        <h1>Hello, world!</h1><br>        <h2>It is {this.state.date.toLocaleTimeString()}.</h2><br>      </div><br>    );<br>  }<br>}<br>注意我们是如何传入props到父构造器中的</p>\n<p>类组件应该总是向父组件传入props</p>\n<p>在<clock>元素中移除移除dete props<br>ReactDOM.render(<br>  <clock>,<br>  document.getElementById(‘root’)<br>);</clock></clock></p>\n<p>The result looks like this:</p>\n<p>class Clock extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {date: new Date()};<br>  }</p>\n<p>  render() {<br>    return (<br>      <div><br>        <h1>Hello, world!</h1><br>        <h2>It is {this.state.date.toLocaleTimeString()}.</h2><br>      </div><br>    );<br>  }<br>}</p>\n<p>ReactDOM.render(<br>  <clock>,<br>  document.getElementById(‘root’)<br>);</clock></p>\n<p><strong>Adding Lifecycle Methods to a Class</strong></p>\n<p>In applications with many components, it’s very important to free up resources taken by the components when they are destroyed.</p>\n<p>We want to set up a timer whenever the Clock is rendered to the DOM for the first time. This is called “mounting” in React.</p>\n<p>We also want to clear that timer whenever the DOM produced by the Clock is removed. This is called “unmounting” in React.</p>\n<p>We can declare special methods on the component class to run some code when a component mounts and unmounts:</p>\n<p>class Clock extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {date: new Date()};<br>  }</p>\n<p>  componentDidMount() {</p>\n<p>  }</p>\n<p>  componentWillUnmount() {</p>\n<p>  }</p>\n<p>  render() {<br>    return (<br>      <div><br>        <h1>Hello, world!</h1><br>        <h2>It is {this.state.date.toLocaleTimeString()}.</h2><br>      </div><br>    );<br>  }<br>}<br>These methods are called “lifecycle hooks”.</p>\n<p>The componentDidMount() hook runs after the component output has been rendered to the DOM. This is a good place to set up a timer:</p>\n<p>  componentDidMount() {<br>    this.timerID = setInterval(<br>      () =&gt; this.tick(),<br>      1000<br>    );<br>  }</p>\n<p>注意到我们是将timeID保存到this上的</p>\n<p>当this.props被react建立且this.state有一个特俗的意义，如果你需要存储一些不会显示在试图中的数据可以自由的手动添加字段到类中</p>\n<p>不在render中使用的数据也不应该出现在state中</p>\n<p>我们将会拆除计时器当componentWillUnmount被触发时，<br> componentWillUnmount() {<br>    clearInterval(this.timerID);<br>  }</p>\n<p>最终我们会实现一个叫做tick的方法，这个方法让组件每秒更新一次</p>\n<p>他将会使用this.setState()指定组件的局部state更新</p>\n<p>class Clock extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {date: new Date()};<br>  }</p>\n<p>  componentDidMount() {<br>    this.timerID = setInterval(<br>      () =&gt; this.tick(),<br>      1000<br>    );<br>  }</p>\n<p>  componentWillUnmount() {<br>    clearInterval(this.timerID);<br>  }</p>\n<p>  tick() {<br>    this.setState({<br>      date: new Date()<br>    });<br>  }</p>\n<p>  render() {<br>    return (<br>      <div><br>        <h1>Hello, world!</h1><br>        <h2>It is {this.state.date.toLocaleTimeString()}.</h2><br>      </div><br>    );<br>  }<br>}</p>\n<p>ReactDOM.render(<br>  <clock>,<br>  document.getElementById(‘root’)<br>);</clock></p>\n<p>现在它能够正常工作了</p>\n<p>让我们简单总结一下是怎么回事并排序事件的触发顺序</p>\n<p>1，当<clock>组件被传入ReactDOM.render()时，react触发了Clock组件的构造函数，自从Clock需要显示当前事件，他使用一个包含时间的对象初始化this.state，我们将会在接下来更新他。<br>2，接着react使用了组件的render函数，这让react了解到那些数据应该在屏幕上显示，react下一步会匹配render的输出更新dom<br>3，当Clock的输出被内嵌到dom中，react触发componentDidMount函数，再此函数中Clock要求浏览器建立一个计时器每秒呼叫组件的tick方法<br>4，浏览器每秒呼叫tick函数，在函数中Clock计划使用setState改变当前时间去更新视图，感谢setState，react才能知道state被改变，接着使用render函数去更新那些应该在屏幕上显示的数据，这时，this.state.date将会不同于render函数中的数据，所以render函数的输出将会更新时间。<br>5，如果组件一旦从dom中移除，react将会运行componentWillUnmount函数，所以这个计时器也被停止</clock></p>\n<p>事件处理</p>\n","comments":true,"categories":[{"name":"react","slug":"react","permalink":"http://www.ylioo.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://www.ylioo.com/tags/react/"}]},{"title":"","date":"2018-04-02T15:27:54.881Z","path":"2018/04/02/npm/note/","text":"main main字段指定了模块的入口程序文件。就是说，如果你的模块名叫”foo”，用户安装了它，并且调用了 require(“foo”)，则这个main字段指定的模块的导出对象会被返回。 这应该是一个相对于包根目录的模块标识。 对于大部分模块来说，main字段除了指定一个主入口文件以外没什么其他用处了。 name ：npm包的名称 name and version are most important fields. they are necessary, if your npm package not appoints those two fields, it will not be installed. name and version are assumed a only identifying’s combination.包内容的更改和包版本的更改是同步的。 几个规则： 1.name的长度必须小于等于214个字符。 name不能以”.”(点)或者”_”(下划线)开头。 name中不能包含大写字母。 name最终将被用作URL的一部分、命令行的参数和文件夹名。因此，name不能含有非URL安全的字符。 几个建议： 不要使用已存在的name作为包名。 不要在name中使用”js”和”node”，这会假定这是js文件，一旦你写一个package.json文件，你就可以在”engines”字段中指定解释器引擎。 name字段可能会被作为传输传递给require()函数，因此它最好是简短的、自描述的。 你可能会需要在深入开发一个包之前先检查npm的registry来确认某个name是否被使用过，可以参考https://www.npmjs.com/。 一个name可以用scope来指定一个前缀，比如@myorg/mypackage，可以参考npm-scope。","raw":"**main**\n\nmain字段指定了模块的入口程序文件。就是说，如果你的模块名叫\"foo\"，用户安装了它，并且调用了 require(\"foo\")，则这个main字段指定的模块的导出对象会被返回。\n\n这应该是一个相对于包根目录的模块标识。\n\n对于大部分模块来说，main字段除了指定一个主入口文件以外没什么其他用处了。\n\n**name**<small> ：npm包的名称</small>\n\nname and version are most important fields. they are necessary, if your npm package not appoints those two fields, it will not be installed. name and version are assumed a only identifying's combination.包内容的更改和包版本的更改是同步的。\n\n**几个规则：**\n\n- 1.name的长度必须小于等于214个字符。\n- 2. name不能以\".\"(点)或者\"_\"(下划线)开头。\n- 3. name中不能包含大写字母。\n- 4. name最终将被用作URL的一部分、命令行的参数和文件夹名。因此，name不能含有非URL安全的字符。\n\n**几个建议：**\n\n- 1. 不要使用已存在的name作为包名。\n- 2. 不要在name中使用\"js\"和\"node\"，这会假定这是js文件，一旦你写一个package.json文件，你就可以在\"engines\"字段中指定解释器引擎。\n- 3. name字段可能会被作为传输传递给require()函数，因此它最好是简短的、自描述的。\n- 4. 你可能会需要在深入开发一个包之前先检查npm的registry来确认某个name是否被使用过，可以参考https://www.npmjs.com/。\n- 一个name可以用scope来指定一个前缀，比如@myorg/mypackage，可以参考npm-scope。","content":"<p><strong>main</strong></p>\n<p>main字段指定了模块的入口程序文件。就是说，如果你的模块名叫”foo”，用户安装了它，并且调用了 require(“foo”)，则这个main字段指定的模块的导出对象会被返回。</p>\n<p>这应该是一个相对于包根目录的模块标识。</p>\n<p>对于大部分模块来说，main字段除了指定一个主入口文件以外没什么其他用处了。</p>\n<p><strong>name</strong><small> ：npm包的名称</small></p>\n<p>name and version are most important fields. they are necessary, if your npm package not appoints those two fields, it will not be installed. name and version are assumed a only identifying’s combination.包内容的更改和包版本的更改是同步的。</p>\n<p><strong>几个规则：</strong></p>\n<ul>\n<li>1.name的长度必须小于等于214个字符。</li>\n<li><ol start=\"2\">\n<li>name不能以”.”(点)或者”_”(下划线)开头。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>name中不能包含大写字母。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>name最终将被用作URL的一部分、命令行的参数和文件夹名。因此，name不能含有非URL安全的字符。</li>\n</ol>\n</li>\n</ul>\n<p><strong>几个建议：</strong></p>\n<ul>\n<li><ol>\n<li>不要使用已存在的name作为包名。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>不要在name中使用”js”和”node”，这会假定这是js文件，一旦你写一个package.json文件，你就可以在”engines”字段中指定解释器引擎。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>name字段可能会被作为传输传递给require()函数，因此它最好是简短的、自描述的。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>你可能会需要在深入开发一个包之前先检查npm的registry来确认某个name是否被使用过，可以参考<a href=\"https://www.npmjs.com/。\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/。</a></li>\n</ol>\n</li>\n<li>一个name可以用scope来指定一个前缀，比如@myorg/mypackage，可以参考npm-scope。</li>\n</ul>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:54.795Z","path":"2018/04/02/nodejs/npminstall/","text":"npm install –prefix // 安装到制定目录","raw":"npm install --prefix <directory>\t// 安装到制定目录","content":"<p>npm install –prefix <directory>    // 安装到制定目录</directory></p>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:54.699Z","path":"2018/04/02/math/微分方程/","text":"微分方程的基本概念 def: 含有未知函数的倒数或微分的方程（常微分方程） 方程的阶数： 方程中未知数的最高阶导数的阶数 通解： 如果微分方程中含有任意常数，and任意常数的个数与微分方程的阶数相等 特解： 确定了通解中的任意常数 n阶微分方程： F(x,y,y’,y’’,…,y(n)) 微分方程的初值问题 *隐函数求导： 2xy - 2y2 = c 2y + 2xy’ - 2yy’ = 0* 可分离变量的微分方程 beacuse：a = ln ea so: x2 = ln ex2 凑微分法","raw":"**微分方程的基本概念**\n\n**def:**\n\t含有未知函数的倒数或微分的方程（常微分方程）\n\n方程的阶数：\n\t方程中未知数的最高阶导数的阶数\n\n通解：\n\t如果微分方程中含有任意常数，and任意常数的个数与微分方程的阶数相等\n\n特解：\n\t确定了通解中的任意常数\n\nn阶微分方程： F(x,y,y',y'',...,y<sup>(n)</sup>)\n\n微分方程的初值问题\n\n![](https://i.imgur.com/QgJ2WXd.png)\n\n*隐函数求导：\t\n\n\n- 2xy - 2y<sup>2</sup> = c\n- 2y + 2xy' - 2yy' = 0*\n\n\n可分离变量的微分方程\n\n![](https://i.imgur.com/dgHeFOT.png)\n\nbeacuse：a = ln e<sup>a</sup>\n\nso:\t\tx<sup>2</sup> = ln e<sup>x<sup>2</sup></sup>\n\n凑微分法","content":"<p><strong>微分方程的基本概念</strong></p>\n<p><strong>def:</strong><br>    含有未知函数的倒数或微分的方程（常微分方程）</p>\n<p>方程的阶数：<br>    方程中未知数的最高阶导数的阶数</p>\n<p>通解：<br>    如果微分方程中含有任意常数，and任意常数的个数与微分方程的阶数相等</p>\n<p>特解：<br>    确定了通解中的任意常数</p>\n<p>n阶微分方程： F(x,y,y’,y’’,…,y<sup>(n)</sup>)</p>\n<p>微分方程的初值问题</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.imgur.com/QgJ2WXd.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>*隐函数求导：    </p>\n<ul>\n<li>2xy - 2y<sup>2</sup> = c</li>\n<li>2y + 2xy’ - 2yy’ = 0*</li>\n</ul>\n<p>可分离变量的微分方程</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.imgur.com/dgHeFOT.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>beacuse：a = ln e<sup>a</sup></p>\n<p>so:        x<sup>2</sup> = ln e<sup>x<sup>2</sup></sup></p>\n<p>凑微分法</p>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:54.624Z","path":"2018/04/02/linux/vim/","text":"进入 vim： vim insert: 输入: i save and exit: if you are in insert mode,first click “esc”,then input “:wq” (w: write; q: quit;) end input “enter” other ways: input &quot;x: ( = wq); click &quot;shift + zz&quot; watch only: cat normal quit: 前提是没有改变过内容 first click “esc”,then input “:q” quit without save: first click “esc”,then input “:q!”","raw":"进入 vim：\n\tvim <filename>\n\ninsert:\n\t输入: i\n\nsave and exit:\n\tif you are in insert mode,first click \"esc\",then input \":wq\"\n\t(w: write;\n\tq: quit;)\n\tend input \"enter\"\n\t\n\tother ways: input \"x: ( = wq);\n\t\t\t\tclick \"shift + zz\"\n\nwatch only:\n\tcat <filename>\n\n\nnormal quit:\n\t前提是没有改变过内容\n\tfirst click \"esc\",then input \":q\"\n\nquit without save:\n\tfirst click \"esc\",then input \":q!\"","content":"<p>进入 vim：<br>    vim <filename></filename></p>\n<p>insert:<br>    输入: i</p>\n<p>save and exit:<br>    if you are in insert mode,first click “esc”,then input “:wq”<br>    (w: write;<br>    q: quit;)<br>    end input “enter”</p>\n<pre><code>other ways: input &quot;x: ( = wq);\n            click &quot;shift + zz&quot;\n</code></pre><p>watch only:<br>    cat <filename></filename></p>\n<p>normal quit:<br>    前提是没有改变过内容<br>    first click “esc”,then input “:q”</p>\n<p>quit without save:<br>    first click “esc”,then input “:q!”</p>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:54.562Z","path":"2018/04/02/javascript/ast/","text":"The AST(abstract syntax tree)(http://blog.csdn.net/dear_mr/article/details/72587908)Def: In computer science, an abstract syntax tree(AST), ro just syntax tree, is a tree representation of the abstract syntactic structure of source code written in a programming language. Translation: 在计算机科学中，抽象语法树，或者语法树，时源代码的抽象语法结构的树状代表形式，这里特指编程语言的源代码。 Javascript的语法是为了给开发者更好的编程而设计，但是不适合程序的理解。所以需要转化为SAT来更适合程序的分析，浏览器编译器一般会把源代码转化为AST来进一步的分析等其他操作。 以下只介绍javascript相关的抽象语法树 var a = 3; a + 5 那么它的抽象语法树就类似： Javascript Parse javascript parse, 把js源码转化为抽象语法树的解析器。 浏览器会把js源码通过解析器转化为抽象语法树，在进一步转化为字节码或直接生成机器码。 一般来说每个js引擎都会有自己的抽象语法树格式，Chrome的V8引擎,firefox的spidermonkey，MDN提供了详细的 spidermonkey AST format 的详细说明。 发展到现在可能不同的JavaScript Parser的AST格式会不同，或基于SpiderMonkey AST format，或重新设计自己的AST format，或基于SpiderMonkey AST format优化改进。通过优化抽象语法树，来使程序运行的更快，也是一种提高效率的方法。 常用的JavaScript Parser有： Esprima UglifyJS2 Traceur Acorn Shift 生成并使用抽象语法树通过 esprima , 把一个名字为ast的空函数的源码生成一颗AST树： var esprima = require(&apos;esprima&apos;); var code = &apos;function ast(){}&apos;; var ast = esprima.parse(code); 生成的抽象语法树长这样： { &quot;type&quot;: &quot;Program&quot;, &quot;body&quot;: [{ &quot;type&quot;: &quot;FunctionDeclaration&quot;, &quot;id&quot;: { &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;ast&quot;, &quot;range&quot;: [ 9, 12 ] }, &quot;params&quot;: [], &quot;body&quot;: { &quot;type&quot;: &quot;BlockStatement&quot;, &quot;body&quot;: [], &quot;range&quot;: [ 14, 16 ] }, &quot;generator&quot;: false, &quot;expression&quot;: false, &quot;range&quot;: [ 0, 16 ] } ], &quot;sourceType&quot;: &quot;module&quot;, &quot;range&quot;: [ 0, 16 ] } 通过 estraverse 遍历并且更新抽象语法树，把函数名称改为ast_awsome： ... var estraverse = require(&apos;estraverse&apos;); estraverse.traverse(ast, { enter: function (node) { node.name += &quot;_awsome&quot;; } }); 通过 escodegen 将AST重新生成为源码： ... var escodegen = require(&quot;escodegen&quot;); var regenerated_code = escodegen.parse(ast) AST三板斧： 通过 esprima 把源码转化为AST通过 estraverse 遍历并更新AST通过 escodegen 将AST重新生成源码抽象语法树的用途浏览器最先就会把源码解析为抽象语法树，对浏览器而言AST的作用非常重要。 对开发者而言，AST的作用就是可以精准的定位到代码的任何地方，它就像是是你的手术刀，对代码进行一系列的操作。 常见的几种用途： 代码语法的检查、代码风格的检查、代码的格式化、代码的高亮、代码错误提示、代码自动补全等等如JSLint、JSHint对代码错误或风格的检查，发现一些潜在的错误IDE的错误提示、格式化、高亮、自动补全等等代码混淆压缩UglifyJS2等优化变更代码，改变代码结构使达到想要的结构代码打包工具webpack、rollup等等CommonJS、AMD、CMD、UMD等代码规范之间的转化CoffeeScript、TypeScript、JSX等转化为原生Javascript","raw":"<h1>The AST(abstract syntax tree)</h1>\n(http://blog.csdn.net/dear_mr/article/details/72587908)</p>\n<strong>Def:</strong><br/>\n> In computer science, an abstract syntax tree(AST), ro just syntax tree, is a tree representation of the abstract syntactic structure of source code written in a programming language. \n\n**Translation:**<br/>\n\t在计算机科学中，抽象语法树，或者语法树，时源代码的抽象语法结构的树状代表形式，这里特指编程语言的源代码。\n\n----------\n\n*Javascript*的语法是为了给开发者更好的编程而设计，但是不适合程序的理解。所以需要转化为SAT来更适合程序的分析，浏览器编译器一般会把源代码转化为AST来进一步的分析等其他操作。\n\n\n以下只介绍*javascript*相关的抽象语法树\n\n    var a = 3;\n    a + 5\n\n那么它的抽象语法树就类似：\n\n![](https://i.imgur.com/cuTaRSW.png)\n\n\n***Javascript Parse***\n\n*javascript parse*, 把*js*源码转化为抽象语法树的解析器。<br/>\n\n浏览器会把*js*源码通过解析器转化为抽象语法树，在进一步转化为字节码或直接生成机器码。<br/>\n\n一般来说每个*js*引擎都会有自己的抽象语法树格式，*Chrome*的V8引擎,*firefox*的*spidermonkey*，**MDN**提供了详细的 *spidermonkey AST format* 的详细说明。<br/>\n\n发展到现在可能不同的*JavaScript Parser*的AST格式会不同，或基于*SpiderMonkey AST format*，或重新设计自己的*AST format*，或基于*SpiderMonkey AST format*优化改进。通过优化抽象语法树，来使程序运行的更快，也是一种提高效率的方法。<br/>\n\n\n- 常用的JavaScript Parser有：\n-  Esprima\n-  UglifyJS2\n-  Traceur\n-  Acorn\n-  Shift\n\n</br>\n\n**生成并使用抽象语法树**\n通过 esprima , 把一个名字为ast的空函数的源码生成一颗AST树：\n\n    var esprima = require('esprima');\n    var code = 'function ast(){}';\n    var ast = esprima.parse(code);\n生成的抽象语法树长这样：\n\n    {\n      \"type\": \"Program\",\n      \"body\": [{\n      \"type\": \"FunctionDeclaration\",\n      \"id\": {\n        \"type\": \"Identifier\",\n        \"name\": \"ast\",\n        \"range\": [\n          9,\n          12\n        ]\n      },\n      \"params\": [],\n      \"body\": {\n        \"type\": \"BlockStatement\",\n        \"body\": [],\n        \"range\": [\n          14,\n          16\n        ]\n      },\n      \"generator\": false,\n      \"expression\": false,\n      \"range\": [\n        0,\n        16\n      ]\n    }\n      ],\n      \"sourceType\": \"module\",\n      \"range\": [\n    0,\n    16\n      ]\n    }\n通过 estraverse 遍历并且更新抽象语法树，把函数名称改为ast_awsome：\n\n    ...\n    var estraverse = require('estraverse');\n    estraverse.traverse(ast, {\n        enter: function (node) {\n            node.name += \"_awsome\";\n        }\n    });\n通过 escodegen 将AST重新生成为源码：\n\n    ...\n    var escodegen = require(\"escodegen\");\n    var regenerated_code = escodegen.parse(ast)\n\n**AST三板斧：**\n\n通过 esprima 把源码转化为AST\n通过 estraverse 遍历并更新AST\n通过 escodegen 将AST重新生成源码\n抽象语法树的用途\n浏览器最先就会把源码解析为抽象语法树，对浏览器而言AST的作用非常重要。\n\n对开发者而言，AST的作用就是可以精准的定位到代码的任何地方，它就像是是你的手术刀，对代码进行一系列的操作。\n\n常见的几种用途：\n\n代码语法的检查、代码风格的检查、代码的格式化、代码的高亮、代码错误提示、代码自动补全等等\n如JSLint、JSHint对代码错误或风格的检查，发现一些潜在的错误\nIDE的错误提示、格式化、高亮、自动补全等等\n代码混淆压缩\nUglifyJS2等\n优化变更代码，改变代码结构使达到想要的结构\n代码打包工具webpack、rollup等等\nCommonJS、AMD、CMD、UMD等代码规范之间的转化\nCoffeeScript、TypeScript、JSX等转化为原生Javascript","content":"<p></p><h1>The AST(abstract syntax tree)</h1><br>(<a href=\"http://blog.csdn.net/dear_mr/article/details/72587908\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/dear_mr/article/details/72587908</a>)<p></p><br><strong>Def:</strong><br><p></p>\n<blockquote>\n<p>In computer science, an abstract syntax tree(AST), ro just syntax tree, is a tree representation of the abstract syntactic structure of source code written in a programming language. </p>\n</blockquote>\n<p><strong>Translation:</strong><br><br>    在计算机科学中，抽象语法树，或者语法树，时源代码的抽象语法结构的树状代表形式，这里特指编程语言的源代码。</p>\n<hr>\n<p><em>Javascript</em>的语法是为了给开发者更好的编程而设计，但是不适合程序的理解。所以需要转化为SAT来更适合程序的分析，浏览器编译器一般会把源代码转化为AST来进一步的分析等其他操作。</p>\n<p>以下只介绍<em>javascript</em>相关的抽象语法树</p>\n<pre><code>var a = 3;\na + 5\n</code></pre><p>那么它的抽象语法树就类似：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.imgur.com/cuTaRSW.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p><strong><em>Javascript Parse</em></strong></p>\n<p><em>javascript parse</em>, 把<em>js</em>源码转化为抽象语法树的解析器。<br></p>\n<p>浏览器会把<em>js</em>源码通过解析器转化为抽象语法树，在进一步转化为字节码或直接生成机器码。<br></p>\n<p>一般来说每个<em>js</em>引擎都会有自己的抽象语法树格式，<em>Chrome</em>的V8引擎,<em>firefox</em>的<em>spidermonkey</em>，<strong>MDN</strong>提供了详细的 <em>spidermonkey AST format</em> 的详细说明。<br></p>\n<p>发展到现在可能不同的<em>JavaScript Parser</em>的AST格式会不同，或基于<em>SpiderMonkey AST format</em>，或重新设计自己的<em>AST format</em>，或基于<em>SpiderMonkey AST format</em>优化改进。通过优化抽象语法树，来使程序运行的更快，也是一种提高效率的方法。<br></p>\n<ul>\n<li>常用的JavaScript Parser有：</li>\n<li>Esprima</li>\n<li>UglifyJS2</li>\n<li>Traceur</li>\n<li>Acorn</li>\n<li>Shift</li>\n</ul>\n<p><br></p>\n<p><strong>生成并使用抽象语法树</strong><br>通过 esprima , 把一个名字为ast的空函数的源码生成一颗AST树：</p>\n<pre><code>var esprima = require(&apos;esprima&apos;);\nvar code = &apos;function ast(){}&apos;;\nvar ast = esprima.parse(code);\n</code></pre><p>生成的抽象语法树长这样：</p>\n<pre><code>{\n  &quot;type&quot;: &quot;Program&quot;,\n  &quot;body&quot;: [{\n  &quot;type&quot;: &quot;FunctionDeclaration&quot;,\n  &quot;id&quot;: {\n    &quot;type&quot;: &quot;Identifier&quot;,\n    &quot;name&quot;: &quot;ast&quot;,\n    &quot;range&quot;: [\n      9,\n      12\n    ]\n  },\n  &quot;params&quot;: [],\n  &quot;body&quot;: {\n    &quot;type&quot;: &quot;BlockStatement&quot;,\n    &quot;body&quot;: [],\n    &quot;range&quot;: [\n      14,\n      16\n    ]\n  },\n  &quot;generator&quot;: false,\n  &quot;expression&quot;: false,\n  &quot;range&quot;: [\n    0,\n    16\n  ]\n}\n  ],\n  &quot;sourceType&quot;: &quot;module&quot;,\n  &quot;range&quot;: [\n0,\n16\n  ]\n}\n</code></pre><p>通过 estraverse 遍历并且更新抽象语法树，把函数名称改为ast_awsome：</p>\n<pre><code>...\nvar estraverse = require(&apos;estraverse&apos;);\nestraverse.traverse(ast, {\n    enter: function (node) {\n        node.name += &quot;_awsome&quot;;\n    }\n});\n</code></pre><p>通过 escodegen 将AST重新生成为源码：</p>\n<pre><code>...\nvar escodegen = require(&quot;escodegen&quot;);\nvar regenerated_code = escodegen.parse(ast)\n</code></pre><p><strong>AST三板斧：</strong></p>\n<p>通过 esprima 把源码转化为AST<br>通过 estraverse 遍历并更新AST<br>通过 escodegen 将AST重新生成源码<br>抽象语法树的用途<br>浏览器最先就会把源码解析为抽象语法树，对浏览器而言AST的作用非常重要。</p>\n<p>对开发者而言，AST的作用就是可以精准的定位到代码的任何地方，它就像是是你的手术刀，对代码进行一系列的操作。</p>\n<p>常见的几种用途：</p>\n<p>代码语法的检查、代码风格的检查、代码的格式化、代码的高亮、代码错误提示、代码自动补全等等<br>如JSLint、JSHint对代码错误或风格的检查，发现一些潜在的错误<br>IDE的错误提示、格式化、高亮、自动补全等等<br>代码混淆压缩<br>UglifyJS2等<br>优化变更代码，改变代码结构使达到想要的结构<br>代码打包工具webpack、rollup等等<br>CommonJS、AMD、CMD、UMD等代码规范之间的转化<br>CoffeeScript、TypeScript、JSX等转化为原生Javascript</p>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:54.547Z","path":"2018/04/02/GO/variable/","text":"var variable_a type var variable_b, c, d type var variable_e type = value var name1, name2, name3 type = v1, v2, v3 / defined 3 variables, they are 分别初始化为相应的值 然后Go会根据其相应值得类型来帮助你初始化它们 /var namea, nameb, namec = v1, v2, v3 name1, name2, name3 := v1, v2, v3 := 这个符号直接取代了var和type，这种形式叫做简短声明。不过他只能在函数内部使用；在函数外部无法通过编译，所以一般用var来声明全局变量。 _是一个特俗的变量名，任何赋值给它的值都会被丢弃。 / 我们将值35赋给b，并丢弃34 /_, b := 34, 35 Go对于已经声明但是未使用的变量会在编译阶段报错 常量： 所谓常量，也就是在程序编译阶段就确定下来的值，而程序在运行时无法改变该值，常量可被定义为数值，布尔值或字符串等类型。 const Pi = 3.1415926 const Pi float32 = 3.1415926 Go常量和一般的编程语言不同的是，可以指定相当多的小数位数（例如200位），若指定给float32自动缩短为32bit，、指定给float64缩短为64bit 内置基础类型： Boolean 在GO中，布尔值得类型为bool，值是true或false。 默认为false； 数值类型： 整数类型有无符号和带符号两种。Go同时支持int和uint，这两种类型的长度相同，但具体长度取决于不同编译器的实现。 Go也有直接定义好的位数类型：rune, int8, int16, int32, int64和byte, uint8, uint16, uint32, uint64.其中rune是int32的别称，byte是uint8的别称。 需要注意的是，这些类型的变量之间不允许互相赋值或操作，不然会在编译时引起编译器保存 如下的代码会引起报错 invalid operation : a + b (mismatched types int8 and int32) 字符串： 字符串是由一对双引号&quot;&quot; ro 反引号 `` 括起来定义，他的类型是string 在GO中字符串是不可变的，例如下面的代码编译时会报错 var s string = &quot;awed&quot; s[0] = &apos;c&apos; 应采用以下的方法修改： s := &quot;hello&quot; c := []byte(s) (注： byte是字节型数据， string是字符串型数据。字符串类型的变量，字符码为0到255，可以声明变长和定长字符串。字节型，变量包含二进制数时，使用字节型。在转换格式期间，最好用字节型变量存储二进制数)","raw":"\nvar variable_a type\n\nvar variable_b, c, d type\n\nvar variable_e type = value\n\nvar name1, name2, name3 type = v1, v2, v3\n\n/*\n\tdefined 3 variables, they are 分别初始化为相应的值\n\t然后Go会根据其相应值得类型来帮助你初始化它们\n*/\nvar namea, nameb, namec = v1, v2, v3\n\nname1, name2, name3 := v1, v2, v3\n\n:= 这个符号直接取代了var和type，这种形式叫做简短声明。不过他只能在函数内部使用；在函数外部无法通过编译，所以一般用var来声明全局变量。\n\n_是一个特俗的变量名，任何赋值给它的值都会被丢弃。\n\n/*\n\t我们将值35赋给b，并丢弃34\n*/\n_, b := 34, 35\n\nGo对于已经声明但是未使用的变量会在编译阶段报错\n\n**常量：**\n\t\n\t所谓常量，也就是在程序编译阶段就确定下来的值，而程序在运行时无法改变该值，常量可被定义为数值，布尔值或字符串等类型。\n\n\tconst Pi = 3.1415926\n\tconst Pi float32 = 3.1415926\n\n\tGo常量和一般的编程语言不同的是，可以指定相当多的小数位数（例如200位），若指定给float32自动缩短为32bit，、指定给float64缩短为64bit\n\n\n**内置基础类型：**\n\tBoolean\n\t\t在GO中，布尔值得类型为bool，值是true或false。 默认为false；\n\n\t数值类型：\n\t\t整数类型有无符号和带符号两种。Go同时支持int和uint，这两种类型的长度相同，但具体长度取决于不同编译器的实现。\n\t\tGo也有直接定义好的位数类型：rune, int8, int16, int32, int64和byte, uint8, uint16, uint32, uint64.其中rune是int32的别称，byte是uint8的别称。\n\t\t\t\n\t\t\t需要注意的是，这些类型的变量之间不允许互相赋值或操作，不然会在编译时引起编译器保存\n\t\t\t\n\t\t\t如下的代码会引起报错 invalid operation : a + b (mismatched types int8 and int32)\n\n\t字符串：\n\t\t字符串是由一对双引号\"\" ro 反引号 `` 括起来定义，他的类型是string\n\n\t\t在GO中字符串是不可变的，例如下面的代码编译时会报错\n\t\tvar s string = \"awed\"\n\t\ts[0] = 'c'\n\n\t\t应采用以下的方法修改：\n\t\t\ts := \"hello\"\n\t\t\tc := []byte(s)\n\n\t\t(注： byte是字节型数据， string是字符串型数据。字符串类型的变量，字符码为0到255，可以声明变长和定长字符串。字节型，变量包含二进制数时，使用字节型。在转换格式期间，最好用字节型变量存储二进制数)","content":"<p>var variable_a type</p>\n<p>var variable_b, c, d type</p>\n<p>var variable_e type = value</p>\n<p>var name1, name2, name3 type = v1, v2, v3</p>\n<p>/<em><br>    defined 3 variables, they are 分别初始化为相应的值<br>    然后Go会根据其相应值得类型来帮助你初始化它们\n</em>/<br>var namea, nameb, namec = v1, v2, v3</p>\n<p>name1, name2, name3 := v1, v2, v3</p>\n<p>:= 这个符号直接取代了var和type，这种形式叫做简短声明。不过他只能在函数内部使用；在函数外部无法通过编译，所以一般用var来声明全局变量。</p>\n<p>_是一个特俗的变量名，任何赋值给它的值都会被丢弃。</p>\n<p>/<em><br>    我们将值35赋给b，并丢弃34\n</em>/<br>_, b := 34, 35</p>\n<p>Go对于已经声明但是未使用的变量会在编译阶段报错</p>\n<p><strong>常量：</strong></p>\n<pre><code>所谓常量，也就是在程序编译阶段就确定下来的值，而程序在运行时无法改变该值，常量可被定义为数值，布尔值或字符串等类型。\n\nconst Pi = 3.1415926\nconst Pi float32 = 3.1415926\n\nGo常量和一般的编程语言不同的是，可以指定相当多的小数位数（例如200位），若指定给float32自动缩短为32bit，、指定给float64缩短为64bit\n</code></pre><p><strong>内置基础类型：</strong><br>    Boolean<br>        在GO中，布尔值得类型为bool，值是true或false。 默认为false；</p>\n<pre><code>数值类型：\n    整数类型有无符号和带符号两种。Go同时支持int和uint，这两种类型的长度相同，但具体长度取决于不同编译器的实现。\n    Go也有直接定义好的位数类型：rune, int8, int16, int32, int64和byte, uint8, uint16, uint32, uint64.其中rune是int32的别称，byte是uint8的别称。\n\n        需要注意的是，这些类型的变量之间不允许互相赋值或操作，不然会在编译时引起编译器保存\n\n        如下的代码会引起报错 invalid operation : a + b (mismatched types int8 and int32)\n\n字符串：\n    字符串是由一对双引号&quot;&quot; ro 反引号 `` 括起来定义，他的类型是string\n\n    在GO中字符串是不可变的，例如下面的代码编译时会报错\n    var s string = &quot;awed&quot;\n    s[0] = &apos;c&apos;\n\n    应采用以下的方法修改：\n        s := &quot;hello&quot;\n        c := []byte(s)\n\n    (注： byte是字节型数据， string是字符串型数据。字符串类型的变量，字符码为0到255，可以声明变长和定长字符串。字节型，变量包含二进制数时，使用字节型。在转换格式期间，最好用字节型变量存储二进制数)\n</code></pre>","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:54.489Z","path":"2018/04/02/GO/goDirective/","text":"buildcompile packages and dependenciescleanremove object filesenvprint Go environment infomationfixrun go tool fix on packagefmtrun gofmt on package sourecegetdownload and install packages and dependenciesinstallcompile and install packages and dependencieslistlist packagesruncompile and run Go programtesttest packagestoolrun specified go toolversionprint Go versionvetrun go tool vet on packages","raw":"<div style=\"color:green;font-size:24px\">\n\t\n<p><span style=\"width:120px;display: inline-block\">build</span>compile packages and dependencies</p>\n\n<p><span style=\"width:120px;display: inline-block\">clean</span>remove object files</p>\n\n<p><span style=\"width:120px;display: inline-block\">env</span>print Go environment infomation</p>\n\n<p><span style=\"width:120px;display: inline-block\">fix</span>run go tool fix on package</p>\n\n<p><span style=\"width:120px;display: inline-block\">fmt</span>run gofmt on package sourece</p>\n\n<p><span style=\"width:120px;display: inline-block\">get</span>download and install packages and dependencies</p>\n\n<p><span style=\"width:120px;display: inline-block\">install</span>compile and install packages and dependencies</p>\n\n<p><span style=\"width:120px;display: inline-block\">list</span>list packages</p>\n\n<p><span style=\"width:120px;display: inline-block\">run</span>compile and run Go program</p>\n\n<p><span style=\"width:120px;display: inline-block\">test</span>test packages</p>\n\n<p><span style=\"width:120px;display: inline-block\">tool</span>run specified go tool</p>\n\n<p><span style=\"width:120px;display: inline-block\">version</span>print Go version</p>\n\n<p><span style=\"width:120px;display: inline-block\">vet</span>run go tool vet on packages</p>\n</div>","content":"<div style=\"color:green;font-size:24px\"><br><br><p><span style=\"width:120px;display: inline-block\">build</span>compile packages and dependencies</p><br><br><p><span style=\"width:120px;display: inline-block\">clean</span>remove object files</p><br><br><p><span style=\"width:120px;display: inline-block\">env</span>print Go environment infomation</p><br><br><p><span style=\"width:120px;display: inline-block\">fix</span>run go tool fix on package</p><br><br><p><span style=\"width:120px;display: inline-block\">fmt</span>run gofmt on package sourece</p><br><br><p><span style=\"width:120px;display: inline-block\">get</span>download and install packages and dependencies</p><br><br><p><span style=\"width:120px;display: inline-block\">install</span>compile and install packages and dependencies</p><br><br><p><span style=\"width:120px;display: inline-block\">list</span>list packages</p><br><br><p><span style=\"width:120px;display: inline-block\">run</span>compile and run Go program</p><br><br><p><span style=\"width:120px;display: inline-block\">test</span>test packages</p><br><br><p><span style=\"width:120px;display: inline-block\">tool</span>run specified go tool</p><br><br><p><span style=\"width:120px;display: inline-block\">version</span>print Go version</p><br><br><p><span style=\"width:120px;display: inline-block\">vet</span>run go tool vet on packages</p><br></div>","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:54.457Z","path":"2018/04/02/GO/goConfigure/","text":"windows下安装go 编辑器visual stdio code 保存时提示缺少语法检测extension 但是安装时提示失败（所有扩展安装失败） 我的go安装在d:go 首先在src/golang.org/x/tools下git clone https://github.com/golang/tools.git 这样大部分extension可以安装完成其余的extension可以根据vscode提示去github上依次git clone到相应文件夹，再在bin/下go install “../“ 就行了","raw":"windows下安装go\n\n编辑器visual stdio code\n\n保存时提示缺少语法检测extension\n\n但是安装时提示失败（所有扩展安装失败）\n\n我的go安装在d:go\n\n首先在src/golang.org/x/tools下\ngit clone https://github.com/golang/tools.git\n\n这样大部分extension可以安装完成\n其余的extension可以根据vscode提示去github上依次git clone到相应文件夹，\n再在bin/下\ngo install \"../<path>\" 就行了","content":"<p>windows下安装go</p>\n<p>编辑器visual stdio code</p>\n<p>保存时提示缺少语法检测extension</p>\n<p>但是安装时提示失败（所有扩展安装失败）</p>\n<p>我的go安装在d:go</p>\n<p>首先在src/golang.org/x/tools下<br>git clone <a href=\"https://github.com/golang/tools.git\" target=\"_blank\" rel=\"noopener\">https://github.com/golang/tools.git</a></p>\n<p>这样大部分extension可以安装完成<br>其余的extension可以根据vscode提示去github上依次git clone到相应文件夹，<br>再在bin/下<br>go install “../<path></path>“ 就行了</p>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:54.455Z","path":"2018/04/02/GO/compire/","text":"go语言的format extension会在保存时提示语法或者其他的错误/warning其中每个函数都必须写上commentlike this // [function name] : here you tell us what Salutation is // Printer : what is this? // Greet : describe what this function does // CreateMessage : describe what this function does","raw":"go语言的format extension会在保存时提示语法或者其他的错误/warning\n其中每个函数都必须写上comment\nlike this\n\t<code>\n\t// [function name] : here you tell us what Salutation is</br>\n\t// Printer : what is this?</br>\n\t// Greet : describe what this function does</br>\n\t// CreateMessage : describe what this function does</br>\n\t</code>","content":"<p>go语言的format extension会在保存时提示语法或者其他的错误/warning<br>其中每个函数都必须写上comment<br>like this<br>    <code><br>    // [function name] : here you tell us what Salutation is<br><br>    // Printer : what is this?<br><br>    // Greet : describe what this function does<br><br>    // CreateMessage : describe what this function does<br><br>    </code></p>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:54.420Z","path":"2018/04/02/GO/build/","text":"编译完代码后可以使用go install 生成.a的文件 如何使用呢？ 我们可以在另一个程序中使用import( “path” )来调用； 最后再使用go build 生产.exe的可执行文件","raw":"编译完代码后可以使用go install <filename>生成.a的文件\n\n如何使用呢？\n\t我们可以在另一个程序中使用import(\n\t\t\"path\"\n\t)来调用；\n\n最后再使用go build 生产.exe的可执行文件","content":"<p>编译完代码后可以使用go install <filename>生成.a的文件</filename></p>\n<p>如何使用呢？<br>    我们可以在另一个程序中使用import(<br>        “path”<br>    )来调用；</p>\n<p>最后再使用go build 生产.exe的可执行文件</p>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:54.324Z","path":"2018/04/02/data struct/1/","text":"数据：指能够被计算机识别，存储额加工处理的信息载体。数据元素：就是数据的基本单位，在某些情况下，数据元素也成为元素，节点，顶点，记录。数据元素有时也可以由若干数据项组成。数据结构：指的是数据之间的相互关系，即数据的组织形式。 数据结构一般包括以下三方面： 1.数据元素之间的逻辑关系，也称数据的逻辑结构： 数据的逻辑结构是从逻辑关系上描述数据，与数据的存储无关，是独立于i计算机的。数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。2.数据元素机及其关系在计算机存储器内的表示称数据的存储结构；3.数据的运算，即对数据施加的操作： 数据的运算定义在数据的逻辑结构上，每种逻辑结构都有一个运算的集合。最常用的检索，插入，删除，更新，排序等运算实际上只是在抽象的数据上施加的一系列抽象的操作。 逻辑结构： 表中每一行是一个数据元素（or record， node），由学好，姓名等数据组成。数据元素之间的逻辑关系是：对表中任一节点与他前面相邻且在它前面的节点称直接前趋最多只有一个； 存储结构： 该表的存储结构指的是用计算机语言如何表示节点之间的这种关系，即表中的节点时顺序邻接地存储在一片连续的单元之中，还是用指针将这些节点连接在一起？ 数据的logic分类： linear struct： logic characteristic is: if struct is not empty, 则if only if one start node and end node,and all of nodes most 只有one直接前趋andone直接后继。线性table, stack, queue, 串等都是线性结构。 非线性接结构： 逻辑特征是： 一个节点可能有多个直接前趋和直接后趋。array, 广义表，tree and graph等数据结构都是非线性结构 数据的四种基本存储方法： 1，顺序存储方法； 2，连接存储方法； 3，索引存储方法； 4，散列存储方法; 按值是否可以分解，可将数据分为两类： 1，原子类型 2，结构类型 抽象数据类型（ADT）： 是指抽象数据的组织和与之相关的操作。可以看作是数据的逻辑结构及其在逻辑结构上定义的操作。抽象数据类型可以看作是描述问题的模型，他独立于具体实现。它的优点是将数据可操作封装在一起，使得用户程序只能通过在ADT中定义的某些操作来访问其中的数据，从而实现信息隐藏。 ADI和class的概念实际上反映了程序或软件设计的两次抽象：ADT相当于实在概念层（抽象层）上描述问题，而类相当于是在实现层上描述问题。不采用ADT的形式来描述数据结构 计算机处理问题的分类： 1：数值计算问题； 2：非数值问题 算法+数据结构 = 程序 数据结构是数据的逻辑结构和存储结构，算法是对数据运算的描述 算法（Algorithm）def:非形式的说，算法是任意一个良定义的计算过程它以一个或多个值作为输入，并产生一个或多个值作为输出； 1，一个算法可以被认为是用来解决一个计算问题的工具 2，一个算法是将一系列输入转化为输出的计算步骤 Algorithm’s description: one algorithm can used by nature language, computer language ro another language to description, only demand is this description must descript calculate process in accurate.描述算法最合适的语言是介于计算机语言与自然语言之间的伪语言 算法的时间性能分析（1）算法所耗费的时间=算法中每条语句的执行时间之和每条语句的执行时间=语句的执行次数(即频度))×语句执行一次所需时间的乘积。 算法求解问题的输入量称为问题的规模(Size),用一个整数表示。 一个算法的时间复杂度(也称时间复杂性)T(n)是该算法的时间耗费，是该算法所求解问题规模n 的函数。当问题的规模n 趋向无穷大时，时间复杂度T(n)的数量级(阶)称为算法的渐进时间复杂度。【例3】算法MatrixMultidy 的时间复杂度T(n)如(1.1)式所示，当n 趋向无穷大时，显然有当n 充分大时，T(n)和n 3 之比是一个不等于零的常数。即T(n)和n 3 是同阶的，或者说T(n)和n 3 的数量级相同。记作T(n)=O(n 3)是算法MatrixMultiply 的渐近时间复杂度。 当有若干个循环语句时，算法的时间复杂度由嵌套层数最多的循环语句中最内层语句的频度 f(n)决定的。（因为当n足够大时，最内层的时间复杂度相比于外层的高阶无穷大） 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间。 一个算法的空间复杂度 S(n)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数。渐近空间复杂度也常常简称为空间复杂度。算法的时间复杂度和空间复杂度合称为算法的复杂度。 线性表的逻辑定义线性表是由n 个数据元素（结点）a1，a2，…，an 组成的有限序列。线性表的逻辑结构特征（对于非空的线性表:）①仅有一个开始结点a1，没有直接前趋，仅有一个直接后继a2；②仅有一个终结结点an，没有直接后继，仅有一个直接前趋an-1；③其余的内部结点ai 都有且仅有一个直接前趋和一个直接后继。常见的线性表的基本运算1． InitList（L） ：构造一个空的线性表 L，即表的初始化。2． ListLength（L） ：求线性表 L 中的结点个数，即求表长。3． GetNode（L，i） ：取线性表L 中的第i 个结点，1≤i≤ListLength(L)4．LocateNode（L，x）：在 L 中查找值为 x 的结点,并返回 x 在 L 中的位置。若 L 中没结点的值为 x，返回个特殊值表示查找失败。5．InsertList（L，x，i）：在表L 的第 i个位置上插入一个值 x6． DeleteList（L，i） ：删除线性表 L 的第i 个结点 void InsertList(SeqList *L，DataType x，int i){//将新结点x 插入L 所指的顺序表的第i 个结点ai 的位置上int j;if (i&lt;1||i&gt;L-&gt;length+1)Error(“position error”);//非法位置，退出运行if (L-&gt;length&gt;=ListSize)Error(“overflow”); //表空间溢出，退出运行for(j=L-&gt;length-1;j&gt;=i-1;j–)L-&gt;data[j+1]=L-&gt;data[j];//结点后移L-&gt;data[i-1]=x; //插入xL-&gt;Length++; //表长加1 } 递归是一种强有力的数学工具，他可以使问题的描述和求解变得简洁和清晰。递归算法常常比非递归算法更容易设计，当问题本身所涉及的数据结构是递归定义时，使递归算法特别合适。 若在一个函数，过程或者数据结构定义的内部，直接（或间接）出现定义本身的应用，则称他们是递归的，或者递归定义的。 递归定义的设计步骤 step1： 将规模较大的问题分解成一个或多个规模更小，但更具有类似元问题特性的子问题。即较大的问题递归地用较小的子问题来描述，解原文题的方法同样可以用来解决子问题。 step2： 确定一个或多个无需分解，可直接求解的最小子问题（递归的终止条件） stack 在递归算法的内部实现中所起到的作用。1.调用函数时：系统将会为调用者构造一个由参数table和return addr组成的activation record，并将其压入由系统提供的运行时刻stack的栈顶，然后将程序的控制权转移到被调用的函数。若函数存在局部变量，则在运行时刻栈的2栈顶也要为其分配相应的空间。因此，活动记录和这些局部变量形成了一个可供被调用函数使用的活动结构。参数表的内容为实参返回地址是函数调用语句的下一指令的位置。2.被调函数执行完毕时：系统将运行时刻栈栈顶的活动结构退栈，并根据退栈的活动结构中所保存的返回地址将程序的控制权转移给调用者继续执行。","raw":"数据：指能够被计算机识别，存储额加工处理的信息载体。\n数据元素：就是数据的基本单位，在某些情况下，数据元素也成为元素，节点，顶点，记录。数据元素有时也可以由若干数据项组成。\n数据结构：指的是数据之间的相互关系，即数据的组织形式。\n\n数据结构一般包括以下三方面：\n\n1.数据元素之间的逻辑关系，也称数据的逻辑结构：\n\t数据的逻辑结构是从逻辑关系上描述数据，与数据的存储无关，是独立于i计算机的。数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。\n2.数据元素机及其关系在计算机存储器内的表示称数据的存储结构；\n3.数据的运算，即对数据施加的操作：\n\t数据的运算定义在数据的逻辑结构上，每种逻辑结构都有一个运算的集合。最常用的检索，插入，删除，更新，排序等运算实际上只是在抽象的数据上施加的一系列抽象的操作。\n\n逻辑结构：\n\t表中每一行是一个数据元素（or record， node），由学好，姓名等数据组成。数据元素之间的逻辑关系是：对表中任一节点与他前面相邻且在它前面的节点称直接前趋最多只有一个；\n\n存储结构：\n\t该表的存储结构指的是用计算机语言如何表示节点之间的这种关系，即表中的节点时顺序邻接地存储在一片连续的单元之中，还是用指针将这些节点连接在一起？\n\n数据的logic分类：\n\tlinear struct： logic characteristic is: if struct is not empty, 则if only if one start node and end node,and all of nodes most 只有one直接前趋andone直接后继。线性table, stack, queue, 串等都是线性结构。\n\t\n\t非线性接结构： 逻辑特征是： 一个节点可能有多个直接前趋和直接后趋。array, 广义表，tree and graph等数据结构都是非线性结构\n\n数据的四种基本存储方法：\n\t1，顺序存储方法；\n\t2，连接存储方法；\n\t3，索引存储方法；\n\t4，散列存储方法;\n\n按值是否可以分解，可将数据分为两类：\n\t1，原子类型\n\t2，结构类型\n\n抽象数据类型（ADT）：\n\t是指抽象数据的组织和与之相关的操作。可以看作是数据的逻辑结构及其在逻辑结构上定义的操作。抽象数据类型可以看作是描述问题的模型，他独立于具体实现。它的优点是将数据可操作封装在一起，使得用户程序只能通过在ADT中定义的某些操作来访问其中的数据，从而实现信息隐藏。\n\tADI和class的概念实际上反映了程序或软件设计的两次抽象：ADT相当于实在概念层（抽象层）上描述问题，而类相当于是在实现层上描述问题。不采用ADT的形式来描述数据结构\n\n计算机处理问题的分类：\n\t1：数值计算问题；\n\t2：非数值问题\n\n算法+数据结构 = 程序\n\n数据结构是数据的逻辑结构和存储结构，算法是对数据运算的描述\n\n算法（Algorithm）\ndef:非形式的说，算法是任意一个良定义的计算过程它以一个或多个值作为输入，并产生一个或多个值作为输出；\n\t1，一个算法可以被认为是用来解决一个计算问题的工具\n\t2，一个算法是将一系列输入转化为输出的计算步骤\n\nAlgorithm's description: one algorithm can used by nature language, computer language ro another language to description, only demand is this description must descript calculate process in accurate.描述算法最合适的语言是介于计算机语言与自然语言之间的伪语言\n\n算法的时间性能分析\n（1）算法所耗费的时间=算法中每条语句的执行时间之和\n每条语句的执行时间=语句的执行次数(即频度))×语句执行一次所需时间的乘积。\n\n算法求解问题的输入量称为问题的规模(Size),用一个整数表示。\n\n一个算法的时间复杂度(也称时间复杂性)T(n)是该算法的时间耗费，是该算法所求解问题规模n 的函数。当问题的规模n 趋向无穷大时，\n时间复杂度T(n)的数量级(阶)称为算法的渐进时间复杂度。\n【例3】算法MatrixMultidy 的时间复杂度T(n)如(1.1)式所示，当n 趋向无穷大时，显然有\n当n 充分大时，T(n)和n 3 之比是一个不等于零的常数。即T(n)和n 3 是同阶的，或者说T(n)和n 3 的数量级相同。记作T(n)=O(n 3)是算\n法MatrixMultiply 的渐近时间复杂度。\n\n当有若干个循环语句时，算法的时间复杂度由嵌套层数最多的循环语句中最内层语句的频度 f(n)决定的。（因为当n足够大时，最内层的时间复杂度相比于外层的高阶无穷大）\n\n平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间。\n\n一个算法的空间复杂度 S(n)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数。渐近空间复杂度也常常简称为空间复杂度。\n算法的时间复杂度和空间复杂度合称为算法的复杂度。\n\n线性表的逻辑定义\n线性表是由n 个数据元素（结点）a1，a2，…，an 组成的有限序列。\n线性表的逻辑结构特征（对于非空的线性表:）\n①仅有一个开始结点a1，没有直接前趋，仅有一个直接后继a2；\n②仅有一个终结结点an，没有直接后继，仅有一个直接前趋an-1；\n③其余的内部结点ai 都有且仅有一个直接前趋和一个直接后继。\n常见的线性表的基本运算\n1． InitList（L） ：构造一个空的线性表 L，即表的初始化。\n2． ListLength（L） ：求线性表 L 中的结点个数，即求表长。\n3． GetNode（L，i） ：取线性表L 中的第i 个结点，1≤i≤ListLength(L)\n4．LocateNode（L，x）：在 L 中查找值为 x 的结点,并返回 x 在 L 中的位置。若 L 中没结点的值为 x，返回个特殊值表示查找失败。\n5．InsertList（L，x，i）：在表L 的第 i个位置上插入一个值 x\n6． DeleteList（L，i） ：删除线性表 L 的第i 个结点\n\nvoid InsertList(SeqList *L，DataType x，int i)\n{//将新结点x 插入L 所指的顺序表的第i 个结点ai 的位置上\nint j;\nif (i<1||i>L->length+1)\nError(\"position error\");//非法位置，退出运行\nif (L->length>=ListSize)\nError(\"overflow\"); //表空间溢出，退出运行\nfor(j=L->length-1;j>=i-1;j--)\nL->data[j+1]=L->data[j];//结点后移\nL->data[i-1]=x; //插入x\nL->Length++; //表长加1 }\n\n递归是一种强有力的数学工具，他可以使问题的描述和求解变得简洁和清晰。递归算法常常比非递归算法更容易设计，当问题本身所涉及的数据结构是递归定义时，使递归算法特别合适。\n\t\n- 若在一个函数，过程或者数据结构定义的内部，直接（或间接）出现定义本身的应用，则称他们是递归的，或者递归定义的。\n- 递归定义的设计步骤\n\tstep1： 将规模较大的问题分解成一个或多个规模更小，但更具有类似元问题特性的子问题。即较大的问题递归地用较小的子问题来描述，解原文题的方法同样可以用来解决子问题。\n\tstep2： 确定一个或多个无需分解，可直接求解的最小子问题（递归的终止条件）\n\nstack 在递归算法的内部实现中所起到的作用。\n1.调用函数时：系统将会为调用者构造一个由参数table和return addr组成的activation record，并将其压入由系统提供的运行时刻stack的栈顶，然后将程序的控制权转移到被调用的函数。若函数存在局部变量，则在运行时刻栈的2栈顶也要为其分配相应的空间。因此，活动记录和这些局部变量形成了一个可供被调用函数使用的活动结构。参数表的内容为实参返回地址是函数调用语句的下一指令的位置。\n2.被调函数执行完毕时：系统将运行时刻栈栈顶的活动结构退栈，并根据退栈的活动结构中所保存的返回地址将程序的控制权转移给调用者继续执行。","content":"<p>数据：指能够被计算机识别，存储额加工处理的信息载体。<br>数据元素：就是数据的基本单位，在某些情况下，数据元素也成为元素，节点，顶点，记录。数据元素有时也可以由若干数据项组成。<br>数据结构：指的是数据之间的相互关系，即数据的组织形式。</p>\n<p>数据结构一般包括以下三方面：</p>\n<p>1.数据元素之间的逻辑关系，也称数据的逻辑结构：<br>    数据的逻辑结构是从逻辑关系上描述数据，与数据的存储无关，是独立于i计算机的。数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。<br>2.数据元素机及其关系在计算机存储器内的表示称数据的存储结构；<br>3.数据的运算，即对数据施加的操作：<br>    数据的运算定义在数据的逻辑结构上，每种逻辑结构都有一个运算的集合。最常用的检索，插入，删除，更新，排序等运算实际上只是在抽象的数据上施加的一系列抽象的操作。</p>\n<p>逻辑结构：<br>    表中每一行是一个数据元素（or record， node），由学好，姓名等数据组成。数据元素之间的逻辑关系是：对表中任一节点与他前面相邻且在它前面的节点称直接前趋最多只有一个；</p>\n<p>存储结构：<br>    该表的存储结构指的是用计算机语言如何表示节点之间的这种关系，即表中的节点时顺序邻接地存储在一片连续的单元之中，还是用指针将这些节点连接在一起？</p>\n<p>数据的logic分类：<br>    linear struct： logic characteristic is: if struct is not empty, 则if only if one start node and end node,and all of nodes most 只有one直接前趋andone直接后继。线性table, stack, queue, 串等都是线性结构。</p>\n<pre><code>非线性接结构： 逻辑特征是： 一个节点可能有多个直接前趋和直接后趋。array, 广义表，tree and graph等数据结构都是非线性结构\n</code></pre><p>数据的四种基本存储方法：<br>    1，顺序存储方法；<br>    2，连接存储方法；<br>    3，索引存储方法；<br>    4，散列存储方法;</p>\n<p>按值是否可以分解，可将数据分为两类：<br>    1，原子类型<br>    2，结构类型</p>\n<p>抽象数据类型（ADT）：<br>    是指抽象数据的组织和与之相关的操作。可以看作是数据的逻辑结构及其在逻辑结构上定义的操作。抽象数据类型可以看作是描述问题的模型，他独立于具体实现。它的优点是将数据可操作封装在一起，使得用户程序只能通过在ADT中定义的某些操作来访问其中的数据，从而实现信息隐藏。<br>    ADI和class的概念实际上反映了程序或软件设计的两次抽象：ADT相当于实在概念层（抽象层）上描述问题，而类相当于是在实现层上描述问题。不采用ADT的形式来描述数据结构</p>\n<p>计算机处理问题的分类：<br>    1：数值计算问题；<br>    2：非数值问题</p>\n<p>算法+数据结构 = 程序</p>\n<p>数据结构是数据的逻辑结构和存储结构，算法是对数据运算的描述</p>\n<p>算法（Algorithm）<br>def:非形式的说，算法是任意一个良定义的计算过程它以一个或多个值作为输入，并产生一个或多个值作为输出；<br>    1，一个算法可以被认为是用来解决一个计算问题的工具<br>    2，一个算法是将一系列输入转化为输出的计算步骤</p>\n<p>Algorithm’s description: one algorithm can used by nature language, computer language ro another language to description, only demand is this description must descript calculate process in accurate.描述算法最合适的语言是介于计算机语言与自然语言之间的伪语言</p>\n<p>算法的时间性能分析<br>（1）算法所耗费的时间=算法中每条语句的执行时间之和<br>每条语句的执行时间=语句的执行次数(即频度))×语句执行一次所需时间的乘积。</p>\n<p>算法求解问题的输入量称为问题的规模(Size),用一个整数表示。</p>\n<p>一个算法的时间复杂度(也称时间复杂性)T(n)是该算法的时间耗费，是该算法所求解问题规模n 的函数。当问题的规模n 趋向无穷大时，<br>时间复杂度T(n)的数量级(阶)称为算法的渐进时间复杂度。<br>【例3】算法MatrixMultidy 的时间复杂度T(n)如(1.1)式所示，当n 趋向无穷大时，显然有<br>当n 充分大时，T(n)和n 3 之比是一个不等于零的常数。即T(n)和n 3 是同阶的，或者说T(n)和n 3 的数量级相同。记作T(n)=O(n 3)是算<br>法MatrixMultiply 的渐近时间复杂度。</p>\n<p>当有若干个循环语句时，算法的时间复杂度由嵌套层数最多的循环语句中最内层语句的频度 f(n)决定的。（因为当n足够大时，最内层的时间复杂度相比于外层的高阶无穷大）</p>\n<p>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间。</p>\n<p>一个算法的空间复杂度 S(n)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数。渐近空间复杂度也常常简称为空间复杂度。<br>算法的时间复杂度和空间复杂度合称为算法的复杂度。</p>\n<p>线性表的逻辑定义<br>线性表是由n 个数据元素（结点）a1，a2，…，an 组成的有限序列。<br>线性表的逻辑结构特征（对于非空的线性表:）<br>①仅有一个开始结点a1，没有直接前趋，仅有一个直接后继a2；<br>②仅有一个终结结点an，没有直接后继，仅有一个直接前趋an-1；<br>③其余的内部结点ai 都有且仅有一个直接前趋和一个直接后继。<br>常见的线性表的基本运算<br>1． InitList（L） ：构造一个空的线性表 L，即表的初始化。<br>2． ListLength（L） ：求线性表 L 中的结点个数，即求表长。<br>3． GetNode（L，i） ：取线性表L 中的第i 个结点，1≤i≤ListLength(L)<br>4．LocateNode（L，x）：在 L 中查找值为 x 的结点,并返回 x 在 L 中的位置。若 L 中没结点的值为 x，返回个特殊值表示查找失败。<br>5．InsertList（L，x，i）：在表L 的第 i个位置上插入一个值 x<br>6． DeleteList（L，i） ：删除线性表 L 的第i 个结点</p>\n<p>void InsertList(SeqList *L，DataType x，int i)<br>{//将新结点x 插入L 所指的顺序表的第i 个结点ai 的位置上<br>int j;<br>if (i&lt;1||i&gt;L-&gt;length+1)<br>Error(“position error”);//非法位置，退出运行<br>if (L-&gt;length&gt;=ListSize)<br>Error(“overflow”); //表空间溢出，退出运行<br>for(j=L-&gt;length-1;j&gt;=i-1;j–)<br>L-&gt;data[j+1]=L-&gt;data[j];//结点后移<br>L-&gt;data[i-1]=x; //插入x<br>L-&gt;Length++; //表长加1 }</p>\n<p>递归是一种强有力的数学工具，他可以使问题的描述和求解变得简洁和清晰。递归算法常常比非递归算法更容易设计，当问题本身所涉及的数据结构是递归定义时，使递归算法特别合适。</p>\n<ul>\n<li>若在一个函数，过程或者数据结构定义的内部，直接（或间接）出现定义本身的应用，则称他们是递归的，或者递归定义的。</li>\n<li>递归定义的设计步骤<br>  step1： 将规模较大的问题分解成一个或多个规模更小，但更具有类似元问题特性的子问题。即较大的问题递归地用较小的子问题来描述，解原文题的方法同样可以用来解决子问题。<br>  step2： 确定一个或多个无需分解，可直接求解的最小子问题（递归的终止条件）</li>\n</ul>\n<p>stack 在递归算法的内部实现中所起到的作用。<br>1.调用函数时：系统将会为调用者构造一个由参数table和return addr组成的activation record，并将其压入由系统提供的运行时刻stack的栈顶，然后将程序的控制权转移到被调用的函数。若函数存在局部变量，则在运行时刻栈的2栈顶也要为其分配相应的空间。因此，活动记录和这些局部变量形成了一个可供被调用函数使用的活动结构。参数表的内容为实参返回地址是函数调用语句的下一指令的位置。<br>2.被调函数执行完毕时：系统将运行时刻栈栈顶的活动结构退栈，并根据退栈的活动结构中所保存的返回地址将程序的控制权转移给调用者继续执行。</p>\n","comments":true,"categories":[],"tags":[]}]