{"meta":{"title":"Front-Ends","subtitle":"your life is only once","description":"your life is only once, fuck it","author":"donnie","url":"http://www.github.com/suguanYang"},"pages":[{"title":"categories","date":"2018-04-04T08:55:21.000Z","updated":"2018-04-04T08:55:41.856Z","comments":true,"path":"categories/index.html","permalink":"http://www.github.com/suguanYang/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-04-04T08:56:23.000Z","updated":"2018-04-04T09:06:08.242Z","comments":true,"path":"about/index.html","permalink":"http://www.github.com/suguanYang/about/index.html","excerpt":"","text":"About Me:"},{"title":"tags","date":"2018-04-04T08:54:17.000Z","updated":"2018-04-04T08:54:55.535Z","comments":true,"path":"tags/index.html","permalink":"http://www.github.com/suguanYang/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"汇编基础","slug":"assembly/asm","date":"2018-04-07T16:00:00.000Z","updated":"2018-04-08T08:52:32.892Z","comments":true,"path":"2018/04/08/assembly/asm/","link":"","permalink":"http://www.github.com/suguanYang/2018/04/08/assembly/asm/","excerpt":"","text":"算是对以前大学学的一些复习 0.1. 寄存器： 0.2. 寄存器的种类 0.3. 内存模型: Heap 0.4. 内存模型:Stack 0.5. CPU 指令 0.1. 寄存器：CPU本身只负责运算， 不负责存储数据。数据一般都存储在内存之中，cpu要用的时候就去内存中读写数据。但是，cpu的运行速度要远高于内存的读写，为了避免被拖慢，cpu一般都自带一级缓存和二级缓存。基本上，cpu缓存可以看作是读写速度较快的内存。 但是，cpu缓存还是不够快，另外数据在缓存里面的地址是不固定的，cpu每次读写都要寻址也会拖慢速度。因此，除了缓存之外，cpu还自带了寄存器（register），用来存储最常用的数据。也就是说那些使用最频繁的数据（比如循环变量），都会放在寄存器里面，cpu优先读写寄存器，再由寄存器跟内存交换数据。 寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉cpu去具体的那一个寄存器去拿数据，这样的速度是最快的。有人比喻寄存器是cpu的零级缓存。 0.2. 寄存器的种类早期的x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不指定用途了，但是早期寄存器的名称都被保留了下来。 EAX EBX ECX EDX EDI ESI EBP ESP 上面这八个寄存器当中，前面七个都是通用的。esp寄存器有特定用途，保存当前stack的地址。 我们常看到32位CPU.64位CPU这样的名称，其实指的就是寄存器大小。32位的CPU的寄存器大小就是四个字节。 0.3. 内存模型: Heap寄存器只能存放很少量的数据，大多数的时候，CPU要指挥寄存器，直接跟内存交换数据。所以除了寄存器还必须了解内存怎么储存数据。程序运行的时候，操作系统会给它分配一段内存，用来存储程序和运行时产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000,起始地址是较小的那个地址。 程序运行过程中，对于动态的内存请求(比如新建对象，或者使用malloc命令)，系统与就会从预先分配好的那段内存之中划出一部分给用户，具体规则是从起始地址开始划分(实际上，起始地址会有一段静态数据，这里先忽略)。举例来说，用户要求得到10个字节内存，那么从起始地址0x1000开始给他分配。一直分配到地址(0x100A),如果再要求得到22个字节，那么就分配到0x1020 这种因为用户主动请求而划分出来的内存区域，叫做heap(堆)。它由起始地址开始，从地位地址项高位地址增长。Heap的一个重要的特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。 0.4. 内存模型:Stack除了Heap外，其他的内存占用叫做Stack(栈)。简单说，stack是由函数运行而临时占用的内存区域。 请看下面的例子。 12345int main ()&#123; int a = 2; int b = 3;&#125; 上面代码中，系统开始执行main函数时，会为它在内存里面创建一个帧(frame)，所有main的内部变量(a,b)都保存在这个帧里面。main函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。 如果函数内部调用了其他函数，如下：123456789void new_func(void);int main ()&#123; int a = 2; int b = 3; new_func(); return;&#125; 上面代码中，main函数内部调用了new_func函数，执行到这一行时，系统也会为new_func新建一个帧，用来存储它的内部变量。也就是说，此时同时存在两个帧:main 和 new_func。一般来说，调用栈有多少层，就有多少帧。等到new_func执行完毕，它的帧就会被回收，系统会回到函数main刚才中断执行的地方继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。所有的帧都放在stack，由于帧是一层层叠加的，所以stack叫做栈。生产新的帧叫做入栈(push)，栈的回收叫做出栈(pop)。stack的特点就是，最晚入栈最早出栈（因为最内层的函数调用，最先结束运行）。 stack是由内存区域的结束地址开始，从高位向地位分配。 0.5. CPU 指令 一个实例 了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序example.c。 123456int add_a_and_b(int a, int b) &#123; return a + b;&#125;int main() &#123; return add_a_and_b(2, 3);&#125; gcc 将这个程序转成汇编语言。 1$ gcc -S example.c 上面的命令执行以后，会生成一个文本文件example.s，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。 example.s经过简化以后，大概是下面的样子。12345678910111213_add_a_and_b: push %ebx mov %eax, [%esp+8] mov %ebx, [%esp+12] add %eax, %ebx pop %ebx ret _main: push 3 push 2 call _add_a_and_b add %esp, 8 ret 可以看到，原程序的两个函数add_a_and_b和main，对应两个标签_add_a_and_b和_main。每个标签里面是该函数所转成的 CPU 运行流程。 每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。1push %ebx 这一行里面，push是 CPU 指令，%ebx是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。 下面我就一行一行讲解这个汇编程序，建议读者最好把这个程序，在另一个窗口拷贝一份，省得阅读的时候再把页面滚动上来。 push 指令 根据约定，程序从_main标签开始执行，这时会在 Stack 上为main建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入main这个帧，就会写在 ESP 寄存器所保存的地址。 然后，开始执行第一行代码。1push 3 push指令用于将运算子放入 Stack，这里就是将3写入main这个帧。 虽然看上去很简单，push指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为3的类型是int，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。1push 2 第二行也是一样，push指令将2写入main这个帧，位置紧贴着前面写入的3。这时，ESP 寄存器会再减去 4个字节（累计减去8）。 call 指令第三行的call指令用来调用函数。1call _add_a_and_b 上面的代码表示调用add_a_and_b函数。这时，程序就会去找_add_a_and_b标签，并为该函数建立一个新的帧。 下面就开始执行_add_a_and_b的代码。1push %ebx 这一行表示将 EBX 寄存器里面的值，写入_add_a_and_b这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。 这时，push指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。 mov 指令mov指令用于将一个值写入某个寄存器。1mov %eax, [%esp+8] 这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是2，再将2写入 EAX 寄存器。 下一行代码也是干同样的事情。1mov %ebx, [%esp+12] 上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是3，将其写入 EBX 寄存器。 add 指令add指令用于将两个运算子相加，并将结果写入第一个运算子。1add %eax, %ebx 上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。 pop 指令pop指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。1pop %ebx 上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。 注意，pop指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。 ret 指令ret指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。1ret 可以看到，该指令没有运算子。 随着add_a_and_b函数终止执行，系统就回到刚才main函数中断的地方，继续往下执行。1add %esp, 8 上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的pop操作已经回收了4个字节，这里再回收8个字节，等于全部回收。1ret 最后，main函数运行结束，ret指令退出程序执行。","categories":[{"name":"assembly","slug":"assembly","permalink":"http://www.github.com/suguanYang/categories/assembly/"}],"tags":[{"name":"assembly","slug":"assembly","permalink":"http://www.github.com/suguanYang/tags/assembly/"}]},{"title":"React chinese","slug":"react/React chinese","date":"2018-04-03T16:00:00.000Z","updated":"2018-04-04T08:58:32.221Z","comments":true,"path":"2018/04/04/react/React chinese/","link":"","permalink":"http://www.github.com/suguanYang/2018/04/04/react/React chinese/","excerpt":"","text":"组件和props 组件让你按需分割界面，可重用的块，思考将这些快分割； 组件的概念就像js中的函数，它们可以接受任意的参数（称为props）返回应该显示的react元素 这个简单的方式定义了一个组件，使用js的函数 function Welcome(props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;; }这个函数是一个有效的react组件，因为他接受了一个单一的props（标准的properties）数据对象参数并且返回一个react元素。我们称这样的组件为functional，因为他是字面上的js函数？ 渲染组件 我们可以定义一个react元素代表传统的标签 const ele = &lt;div /&gt;; 元素也可以代表用户自定义的组件 当react看见一个代表用户自定义组件的元素时，它会传入JSX属性到这个组件作为一个单一的对象，我们成这样的对象为props function Welcome(props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;; } const element = &lt;Welcome name=&quot;Sara&quot; /&gt;; ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); 他将会输出Hello, Sara 让我们总结一下在这个例子中方式发生了什么： 1，我们在React.Dom中使用了元素 2，react将{name: “Sara”}作为props传给Welcome组件 3，我们的Welcome组件返回Hello Sara结果 4，react dom匹配Hello Sara有效地更新DOM 注：自定义组件首字母必须大写当一个元素以一个小写的字母开始，它指向一个内建的组件，像 或者 结果将会是一个字符串’div’ 或者 ‘span’,然后传给React.creactEalement，类型以一个大写字母开始，像，编译结果会是React.createElement(Foo),就爱那个会正确的返回一个定义的组件，或者从你的js文件中引入 Composing Compoents(晓不得咋个翻译额，直接引用原文还更容易理解)Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components. For example, we can create an App component that renders Welcome many times: function Welcome(props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;; } function App() { return ( &lt;div&gt; &lt;Welcome name=&quot;Sara&quot; /&gt; &lt;Welcome name=&quot;Cahal&quot; /&gt; &lt;Welcome name=&quot;Edite&quot; /&gt; &lt;/div&gt; ); } ReactDOM.render( &lt;App /&gt;, document.getElementById(&apos;root&apos;) ); Extracting ComponentsDon’t be afraid to split components into smaller components. For example, consider this Comment component: function Comment(props) { return ( &lt;div className=&quot;Comment&quot;&gt; &lt;div className=&quot;UserInfo&quot;&gt; &lt;img className=&quot;Avatar&quot; src={props.author.avatarUrl} alt={props.author.name} /&gt; &lt;div className=&quot;UserInfo-name&quot;&gt; {props.author.name} &lt;/div&gt; &lt;/div&gt; &lt;div className=&quot;Comment-text&quot;&gt; {props.text} &lt;/div&gt; &lt;div className=&quot;Comment-date&quot;&gt; {formatDate(props.date)} &lt;/div&gt; &lt;/div&gt; ); } 它接收auther，text，和date作为props，描述可一个在社交媒体网站上的评论组件 改变这个组件可能会变得很棘手，因为它含有很多层的嵌套，而且它也很难复用在其他的parts。让我们从他上面分割一些组件下来。 首先我们分割头像组件 function Avatar(props) { return ( &lt;img className=&quot;Avatar&quot; src={props.user.avatarUrl} alt={props.user.name} /&gt; ); } 头像组件并不需要知道他是要在一个组件内渲染，这也是为什么我们给一个更为广泛的name: user而不是author作为props 我们建议在组件中的name props在视图中有自己的重点，而不是考虑在上下文中它的使用 现在我们可以使用更小一点的组件 function Comment(props) { return ( {props.author.name} {props.text} {formatDate(props.date)} ); } 接下来我们分割一个userInfo 组件渲染Avatar接下来是user‘s name function UserInfo(props) { return ( {props.user.name} ); } 这让我们简单的组件更进一步 function Comment(props) { return ( {props.text} {formatDate(props.date)} ); } 组件分割也许在刚开始看起来像grunt的工作，但是有一个palette装了复用组件可以在大型app中使用。一个简单的规则是如果你的一部分UI使用了几次(Button, Panel, Avatar)，或者它自己足够复杂（App, FeedStory, Comment），这是一个好的复用组件的标准 props和只读 无论你是否使用function or class定义组件，他必须不能够被修改它自己的props，考虑这个求和函数 function sum(a, b) { return a + b; } 像这样的函数被叫做“pure”，因为他们并不会试图去修改他们的输入，而且当输入相同时总是返回相同的结果。 作为对比，这个函数不是“pure”的，因为它会改变它自己的输入 react是很灵活的，但是他有一个单一的严格规则： 所有的组件都必须像pure函数以尊重他们的props state and Lifecycle 到目前为止我们学习了如何更新UI 我们使用ReactDOM.render()来改变渲染的输出 function tick() { const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); } setInterval(tick, 1000); 在这一章中，我们将会学习如何制作一个时钟组件，他是复用的而且封装性的，它会建立自己的计数器且每秒都会更新 我们先封装一下他是什么样的 function Clock(props) { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); } function tick() { ReactDOM.render( &lt;Clock date={new Date()} /&gt;, document.getElementById(&apos;root&apos;) ); } setInterval(tick, 1000); 无论怎样，它却少了一个关键的需求：事实上Clock建立一个计时器且每秒自动更新UI应该是一个细节上的实现。 理想情况下我们想只写一次然后它自己更新： ReactDOM.render( , document.getElementById(‘root’) ); 为了实现这个，我们需要向组件中添加“state”， state比props更小，但是他是私有的，而且组件对他有完全控制权 我们曾经注意到组件作为类被定义时有一些传统的特性，本地的state正是如此： 一个只能被类使用的变量 简单概括：Converting a Function to a ClassYou can convert a functional component like Clock to a class in five steps: Create an ES6 class, with the same name, that extends React.Component. Add a single empty method to it called render(). Move the body of the function into the render() method. Replace props with this.props in the render() body. Delete the remaining empty function declaration. class Clock extends React.Component { render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.props.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); } } 现在clock组件作为类被定义，而不是函数 这使得我们可以使用附加的局部state和生命周期特性 Adding Local State to a Class 我们将会使用三个步骤从props中移除date到state中：1，在render()函数中使用this.state.date替换this.props.date, class Clock extends React.Component { render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); } }2, 添加一个类的构造器并给this.state初始化 class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); } } 注意我们是如何传入props到父构造器中的 类组件应该总是向父组件传入props 在元素中移除移除dete propsReactDOM.render( , document.getElementById(‘root’)); The result looks like this: class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); } } ReactDOM.render( &lt;Clock /&gt;, document.getElementById(&apos;root&apos;) ); Adding Lifecycle Methods to a Class In applications with many components, it’s very important to free up resources taken by the components when they are destroyed. We want to set up a timer whenever the Clock is rendered to the DOM for the first time. This is called “mounting” in React. We also want to clear that timer whenever the DOM produced by the Clock is removed. This is called “unmounting” in React. We can declare special methods on the component class to run some code when a component mounts and unmounts: class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } componentDidMount() { } componentWillUnmount() { } render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); } } These methods are called “lifecycle hooks”. The componentDidMount() hook runs after the component output has been rendered to the DOM. This is a good place to set up a timer: componentDidMount() { this.timerID = setInterval( () =&gt; this.tick(), 1000 ); } 注意到我们是将timeID保存到this上的 当this.props被react建立且this.state有一个特俗的意义，如果你需要存储一些不会显示在试图中的数据可以自由的手动添加字段到类中 不在render中使用的数据也不应该出现在state中 我们将会拆除计时器当componentWillUnmount被触发时， componentWillUnmount() { clearInterval(this.timerID); } 最终我们会实现一个叫做tick的方法，这个方法让组件每秒更新一次 他将会使用this.setState()指定组件的局部state更新 class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } componentDidMount() { this.timerID = setInterval( () =&gt; this.tick(), 1000 ); } componentWillUnmount() { clearInterval(this.timerID); } tick() { this.setState({ date: new Date() }); } render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); } } ReactDOM.render( &lt;Clock /&gt;, document.getElementById(&apos;root&apos;) ); 现在它能够正常工作了 让我们简单总结一下是怎么回事并排序事件的触发顺序 1，当组件被传入ReactDOM.render()时，react触发了Clock组件的构造函数，自从Clock需要显示当前事件，他使用一个包含时间的对象初始化this.state，我们将会在接下来更新他。2，接着react使用了组件的render函数，这让react了解到那些数据应该在屏幕上显示，react下一步会匹配render的输出更新dom3，当Clock的输出被内嵌到dom中，react触发componentDidMount函数，再此函数中Clock要求浏览器建立一个计时器每秒呼叫组件的tick方法4，浏览器每秒呼叫tick函数，在函数中Clock计划使用setState改变当前时间去更新视图，感谢setState，react才能知道state被改变，接着使用render函数去更新那些应该在屏幕上显示的数据，这时，this.state.date将会不同于render函数中的数据，所以render函数的输出将会更新时间。5，如果组件一旦从dom中移除，react将会运行componentWillUnmount函数，所以这个计时器也被停止","categories":[{"name":"React","slug":"React","permalink":"http://www.github.com/suguanYang/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://www.github.com/suguanYang/tags/React/"}]}]}