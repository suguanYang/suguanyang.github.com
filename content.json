{"meta":{"title":"Front-Ends","subtitle":"fuck the life","description":"your life is only once, fuck it","author":"donnie","url":"suguanyang.github.io"},"pages":[{"title":"categories","date":"2018-04-04T08:55:21.000Z","updated":"2018-04-04T08:55:41.856Z","comments":true,"path":"categories/index.html","permalink":"suguanyang.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-04-04T08:56:23.000Z","updated":"2018-04-04T09:06:08.242Z","comments":true,"path":"about/index.html","permalink":"suguanyang.github.io/about/index.html","excerpt":"","text":"About Me:"},{"title":"tags","date":"2018-04-04T08:54:17.000Z","updated":"2018-04-04T08:54:55.535Z","comments":true,"path":"tags/index.html","permalink":"suguanyang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"React chinese","slug":"react/React chinese","date":"2018-04-03T16:00:00.000Z","updated":"2018-04-04T08:58:32.221Z","comments":true,"path":"2018/04/04/react/React chinese/","link":"","permalink":"suguanyang.github.io/2018/04/04/react/React chinese/","excerpt":"","text":"组件和props 组件让你按需分割界面，可重用的块，思考将这些快分割； 组件的概念就像js中的函数，它们可以接受任意的参数（称为props）返回应该显示的react元素 这个简单的方式定义了一个组件，使用js的函数 function Welcome(props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;; }这个函数是一个有效的react组件，因为他接受了一个单一的props（标准的properties）数据对象参数并且返回一个react元素。我们称这样的组件为functional，因为他是字面上的js函数？ 渲染组件 我们可以定义一个react元素代表传统的标签 const ele = &lt;div /&gt;; 元素也可以代表用户自定义的组件 当react看见一个代表用户自定义组件的元素时，它会传入JSX属性到这个组件作为一个单一的对象，我们成这样的对象为props function Welcome(props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;; } const element = &lt;Welcome name=&quot;Sara&quot; /&gt;; ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); 他将会输出Hello, Sara 让我们总结一下在这个例子中方式发生了什么： 1，我们在React.Dom中使用了元素 2，react将{name: “Sara”}作为props传给Welcome组件 3，我们的Welcome组件返回Hello Sara结果 4，react dom匹配Hello Sara有效地更新DOM 注：自定义组件首字母必须大写当一个元素以一个小写的字母开始，它指向一个内建的组件，像 或者 结果将会是一个字符串’div’ 或者 ‘span’,然后传给React.creactEalement，类型以一个大写字母开始，像，编译结果会是React.createElement(Foo),就爱那个会正确的返回一个定义的组件，或者从你的js文件中引入 Composing Compoents(晓不得咋个翻译额，直接引用原文还更容易理解)Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components. For example, we can create an App component that renders Welcome many times: function Welcome(props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;; } function App() { return ( &lt;div&gt; &lt;Welcome name=&quot;Sara&quot; /&gt; &lt;Welcome name=&quot;Cahal&quot; /&gt; &lt;Welcome name=&quot;Edite&quot; /&gt; &lt;/div&gt; ); } ReactDOM.render( &lt;App /&gt;, document.getElementById(&apos;root&apos;) ); Extracting ComponentsDon’t be afraid to split components into smaller components. For example, consider this Comment component: function Comment(props) { return ( &lt;div className=&quot;Comment&quot;&gt; &lt;div className=&quot;UserInfo&quot;&gt; &lt;img className=&quot;Avatar&quot; src={props.author.avatarUrl} alt={props.author.name} /&gt; &lt;div className=&quot;UserInfo-name&quot;&gt; {props.author.name} &lt;/div&gt; &lt;/div&gt; &lt;div className=&quot;Comment-text&quot;&gt; {props.text} &lt;/div&gt; &lt;div className=&quot;Comment-date&quot;&gt; {formatDate(props.date)} &lt;/div&gt; &lt;/div&gt; ); } 它接收auther，text，和date作为props，描述可一个在社交媒体网站上的评论组件 改变这个组件可能会变得很棘手，因为它含有很多层的嵌套，而且它也很难复用在其他的parts。让我们从他上面分割一些组件下来。 首先我们分割头像组件 function Avatar(props) { return ( &lt;img className=&quot;Avatar&quot; src={props.user.avatarUrl} alt={props.user.name} /&gt; ); } 头像组件并不需要知道他是要在一个组件内渲染，这也是为什么我们给一个更为广泛的name: user而不是author作为props 我们建议在组件中的name props在视图中有自己的重点，而不是考虑在上下文中它的使用 现在我们可以使用更小一点的组件 function Comment(props) { return ( {props.author.name} {props.text} {formatDate(props.date)} ); } 接下来我们分割一个userInfo 组件渲染Avatar接下来是user‘s name function UserInfo(props) { return ( {props.user.name} ); } 这让我们简单的组件更进一步 function Comment(props) { return ( {props.text} {formatDate(props.date)} ); } 组件分割也许在刚开始看起来像grunt的工作，但是有一个palette装了复用组件可以在大型app中使用。一个简单的规则是如果你的一部分UI使用了几次(Button, Panel, Avatar)，或者它自己足够复杂（App, FeedStory, Comment），这是一个好的复用组件的标准 props和只读 无论你是否使用function or class定义组件，他必须不能够被修改它自己的props，考虑这个求和函数 function sum(a, b) { return a + b; } 像这样的函数被叫做“pure”，因为他们并不会试图去修改他们的输入，而且当输入相同时总是返回相同的结果。 作为对比，这个函数不是“pure”的，因为它会改变它自己的输入 react是很灵活的，但是他有一个单一的严格规则： 所有的组件都必须像pure函数以尊重他们的props state and Lifecycle 到目前为止我们学习了如何更新UI 我们使用ReactDOM.render()来改变渲染的输出 function tick() { const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); } setInterval(tick, 1000); 在这一章中，我们将会学习如何制作一个时钟组件，他是复用的而且封装性的，它会建立自己的计数器且每秒都会更新 我们先封装一下他是什么样的 function Clock(props) { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); } function tick() { ReactDOM.render( &lt;Clock date={new Date()} /&gt;, document.getElementById(&apos;root&apos;) ); } setInterval(tick, 1000); 无论怎样，它却少了一个关键的需求：事实上Clock建立一个计时器且每秒自动更新UI应该是一个细节上的实现。 理想情况下我们想只写一次然后它自己更新： ReactDOM.render( , document.getElementById(‘root’) ); 为了实现这个，我们需要向组件中添加“state”， state比props更小，但是他是私有的，而且组件对他有完全控制权 我们曾经注意到组件作为类被定义时有一些传统的特性，本地的state正是如此： 一个只能被类使用的变量 简单概括：Converting a Function to a ClassYou can convert a functional component like Clock to a class in five steps: Create an ES6 class, with the same name, that extends React.Component. Add a single empty method to it called render(). Move the body of the function into the render() method. Replace props with this.props in the render() body. Delete the remaining empty function declaration. class Clock extends React.Component { render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.props.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); } } 现在clock组件作为类被定义，而不是函数 这使得我们可以使用附加的局部state和生命周期特性 Adding Local State to a Class 我们将会使用三个步骤从props中移除date到state中：1，在render()函数中使用this.state.date替换this.props.date, class Clock extends React.Component { render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); } }2, 添加一个类的构造器并给this.state初始化 class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); } } 注意我们是如何传入props到父构造器中的 类组件应该总是向父组件传入props 在元素中移除移除dete propsReactDOM.render( , document.getElementById(‘root’)); The result looks like this: class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); } } ReactDOM.render( &lt;Clock /&gt;, document.getElementById(&apos;root&apos;) ); Adding Lifecycle Methods to a Class In applications with many components, it’s very important to free up resources taken by the components when they are destroyed. We want to set up a timer whenever the Clock is rendered to the DOM for the first time. This is called “mounting” in React. We also want to clear that timer whenever the DOM produced by the Clock is removed. This is called “unmounting” in React. We can declare special methods on the component class to run some code when a component mounts and unmounts: class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } componentDidMount() { } componentWillUnmount() { } render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); } } These methods are called “lifecycle hooks”. The componentDidMount() hook runs after the component output has been rendered to the DOM. This is a good place to set up a timer: componentDidMount() { this.timerID = setInterval( () =&gt; this.tick(), 1000 ); } 注意到我们是将timeID保存到this上的 当this.props被react建立且this.state有一个特俗的意义，如果你需要存储一些不会显示在试图中的数据可以自由的手动添加字段到类中 不在render中使用的数据也不应该出现在state中 我们将会拆除计时器当componentWillUnmount被触发时， componentWillUnmount() { clearInterval(this.timerID); } 最终我们会实现一个叫做tick的方法，这个方法让组件每秒更新一次 他将会使用this.setState()指定组件的局部state更新 class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } componentDidMount() { this.timerID = setInterval( () =&gt; this.tick(), 1000 ); } componentWillUnmount() { clearInterval(this.timerID); } tick() { this.setState({ date: new Date() }); } render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); } } ReactDOM.render( &lt;Clock /&gt;, document.getElementById(&apos;root&apos;) ); 现在它能够正常工作了 让我们简单总结一下是怎么回事并排序事件的触发顺序 1，当组件被传入ReactDOM.render()时，react触发了Clock组件的构造函数，自从Clock需要显示当前事件，他使用一个包含时间的对象初始化this.state，我们将会在接下来更新他。2，接着react使用了组件的render函数，这让react了解到那些数据应该在屏幕上显示，react下一步会匹配render的输出更新dom3，当Clock的输出被内嵌到dom中，react触发componentDidMount函数，再此函数中Clock要求浏览器建立一个计时器每秒呼叫组件的tick方法4，浏览器每秒呼叫tick函数，在函数中Clock计划使用setState改变当前时间去更新视图，感谢setState，react才能知道state被改变，接着使用render函数去更新那些应该在屏幕上显示的数据，这时，this.state.date将会不同于render函数中的数据，所以render函数的输出将会更新时间。5，如果组件一旦从dom中移除，react将会运行componentWillUnmount函数，所以这个计时器也被停止","categories":[{"name":"React","slug":"React","permalink":"suguanyang.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"suguanyang.github.io/tags/React/"}]}]}