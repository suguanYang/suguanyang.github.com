[{"title":"","date":"2018-04-02T15:27:55.018Z","path":"2018/04/02/react/router/","text":"for browser environment we can use react-router-dom, manage dynamic request, for static website History every router will create a history object and for search current location,it will rerender website when it changes.this history obj promise react router provides othercomponent’s reusability, so other components must render in router. if a react router component retrospectto parent but can’t find router component, this componentwill not working. router路由器组建无法接受两个及以上的子元素。基于这种操作的restrict，创建一个组建来渲染应用其余部分是一个有效地方法对于服务端渲染，将应用从router组件中分离也是重要的。","raw":"for browser environment we can use react-router-dom,\n<BrowserRouter> manage dynamic request,\n<HashRouter> for static website\n\n**History**\n\nevery router will create a history object and for search current location,it will rerender website when it changes.\nthis history obj promise react router provides other\ncomponent's reusability, so other components must render in router. if a react router component retrospect \nto parent but can't find router component, this component\nwill not working.\n\n**router**\n路由器组建无法接受两个及以上的子元素。基于这种操作的restrict，\n创建一个<App>组建来渲染应用其余部分是一个有效地方法\n对于服务端渲染，将应用从router组件中分离也是重要的。\n\n\n","content":"<p>for browser environment we can use react-router-dom,</p>\n<p><browserrouter> manage dynamic request,</browserrouter></p>\n<p><hashrouter> for static website</hashrouter></p>\n<p><strong>History</strong></p>\n<p>every router will create a history object and for search current location,it will rerender website when it changes.<br>this history obj promise react router provides other<br>component’s reusability, so other components must render in router. if a react router component retrospect<br>to parent but can’t find router component, this component<br>will not working.</p>\n<p><strong>router</strong><br>路由器组建无法接受两个及以上的子元素。基于这种操作的restrict，<br>创建一个<app>组建来渲染应用其余部分是一个有效地方法<br>对于服务端渲染，将应用从router组件中分离也是重要的。</app></p>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:55.016Z","path":"2018/04/02/react/notice/","text":"在es6中，类里面的方法，不允许直接使用this来指代实例去使用属性 你必须在构造函数中bind this或者使用箭头函数来代替函数声明，或者再调用时绑定this 或者你可以声明一个全局变量，在构造函数中将this赋值给这个全局变量","raw":"在es6中，类里面的方法，不允许直接使用this来指代实例去使用属性\n\n你必须在构造函数中bind this或者使用箭头函数来代替函数声明，或者再调用时绑定this\n\n或者你可以声明一个全局变量，在构造函数中将this赋值给这个全局变量","content":"<p>在es6中，类里面的方法，不允许直接使用this来指代实例去使用属性</p>\n<p>你必须在构造函数中bind this或者使用箭头函数来代替函数声明，或者再调用时绑定this</p>\n<p>或者你可以声明一个全局变量，在构造函数中将this赋值给这个全局变量</p>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:55.010Z","path":"2018/04/02/react/dom/","text":"react可以允许我们通过 ref 来定位一个组件。具体的做法是：先给一个组件设置一个 ref=‘xxx’ 的属性，注意这个ref必须是全局唯一的。 然后就可以通过 this.refs.city 来访问这个组件。但是请注意，这里拿到的只是虚拟DOM，而不是真实的DOM。只有在render方法执行之后，并且react已经完成了DOM的更新，才能通过 this.refs.city.getDOMNode() 来拿到原生的DOM元素。 作者：隔壁陈叔叔链接：https://www.jianshu.com/p/c401e417bd8a來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","raw":"react可以允许我们通过 ref 来定位一个组件。具体的做法是：\n先给一个组件设置一个 ref=‘xxx’ 的属性，注意这个ref必须是全局唯一的。\n\n<input ref=‘city’ />\n然后就可以通过 this.refs.city 来访问这个组件。\n但是请注意，这里拿到的只是虚拟DOM，而不是真实的DOM。\n只有在render方法执行之后，并且react已经完成了DOM的更新，才能通过 this.refs.city.getDOMNode() 来拿到原生的DOM元素。\n\n作者：隔壁陈叔叔\n链接：https://www.jianshu.com/p/c401e417bd8a\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","content":"<p>react可以允许我们通过 ref 来定位一个组件。具体的做法是：<br>先给一个组件设置一个 ref=‘xxx’ 的属性，注意这个ref必须是全局唯一的。</p>\n<p><input ref=\"‘city’\"><br>然后就可以通过 this.refs.city 来访问这个组件。<br>但是请注意，这里拿到的只是虚拟DOM，而不是真实的DOM。<br>只有在render方法执行之后，并且react已经完成了DOM的更新，才能通过 this.refs.city.getDOMNode() 来拿到原生的DOM元素。</p>\n<p>作者：隔壁陈叔叔<br>链接：<a href=\"https://www.jianshu.com/p/c401e417bd8a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/c401e417bd8a</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n","comments":true,"categories":[],"tags":[]},{"title":"","date":"2018-04-02T15:27:54.978Z","path":"2018/04/02/react/begin/","text":"title: react props statedate: 2018年4月03日13:15:08categories: reacttags: [react]description: react基础 组件和props 组件让你按需分割界面，可重用的块，思考将这些快分割； 组件的概念就像js中的函数，它们可以接受任意的参数（称为props）返回应该显示的react元素 这个简单的方式定义了一个组件，使用js的函数function Welcome(props) { return Hello, {props.name};}这个函数是一个有效的react组件，因为他接受了一个单一的props（标准的properties）数据对象参数并且返回一个react元素。我们称这样的组件为functional，因为他是字面上的js函数？ 渲染组件 我们可以定义一个react元素代表传统的标签 const ele = ; 元素也可以代表用户自定义的组件 当react看见一个代表用户自定义组件的元素时，它会传入JSX属性到这个组件作为一个单一的对象，我们成这样的对象为props ex： function Welcome(props) { return Hello, {props.name}; } const element = &lt;Welcome name=&quot;Sara&quot; /&gt;; ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); 他将会输出Hello, Sara 让我们总结一下在这个例子中方式发生了什么： 1，我们在React.Dom中使用了元素 2，react将{name: “Sara”}作为props传给Welcome组件 3，我们的Welcome组件返回Hello Sara结果 4，react dom匹配Hello Sara有效地更新DOM 注：自定义组件首字母必须大写当一个元素以一个小写的字母开始，它指向一个内建的组件，像 或者 结果将会是一个字符串’div’ 或者 ‘span’,然后传给React.creactEalement，类型以一个大写字母开始，像，编译结果会是React.createElement(Foo),就爱那个会正确的返回一个定义的组件，或者从你的js文件中引入 Composing Compoents(晓不得咋个翻译额，直接引用原文还更容易理解)Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components. For example, we can create an App component that renders Welcome many times: function Welcome(props) { return Hello, {props.name};} function App() { return ( );} ReactDOM.render( , document.getElementById(‘root’)); Extracting ComponentsDon’t be afraid to split components into smaller components. For example, consider this Comment component: function Comment(props) { return ( {props.author.name} {props.text} {formatDate(props.date)} );} 它接收auther，text，和date作为props，描述可一个在社交媒体网站上的评论组件 改变这个组件可能会变得很棘手，因为它含有很多层的嵌套，而且它也很难复用在其他的parts。让我们从他上面分割一些组件下来。 首先我们分割头像组件 function Avatar(props) { return ( );} 头像组件并不需要知道他是要在一个组件内渲染，这也是为什么我们给一个更为广泛的name: user而不是author作为props 我们建议在组件中的name props在视图中有自己的重点，而不是考虑在上下文中它的使用 现在我们可以使用更小一点的组件function Comment(props) { return ( {props.author.name} {props.text} {formatDate(props.date)} );} 接下来我们分割一个userInfo 组件渲染Avatar接下来是user‘s namefunction UserInfo(props) { return ( {props.user.name} );} 这让我们简单的组件更进一步function Comment(props) { return ( {props.text} {formatDate(props.date)} );} 组件分割也许在刚开始看起来像grunt的工作，但是有一个palette装了复用组件可以在大型app中使用。一个简单的规则是如果你的一部分UI使用了几次(Button, Panel, Avatar)，或者它自己足够复杂（App, FeedStory, Comment），这是一个好的复用组件的标准 props和只读 无论你是否使用function or class定义组件，他必须不能够被修改它自己的props，考虑这个求和函数function sum(a, b) { return a + b;} 像这样的函数被叫做“pure”，因为他们并不会试图去修改他们的输入，而且当输入相同时总是返回相同的结果。 作为对比，这个函数不是“pure”的，因为它会改变它自己的输入 react是很灵活的，但是他有一个单一的严格规则： 所有的组件都必须像pure函数以尊重他们的props state and Lifecycle 到目前为止我们学习了如何更新UI 我们使用ReactDOM.render()来改变渲染的输出 function tick() { const element = ( Hello, world! It is {new Date().toLocaleTimeString()}. ); ReactDOM.render( element, document.getElementById(‘root’) );} setInterval(tick, 1000); 在这一章中，我们将会学习如何制作一个时钟组件，他是复用的而且封装性的，它会建立自己的计数器且每秒都会更新 我们先封装一下他是什么样的 function Clock(props) { return ( Hello, world! It is {props.date.toLocaleTimeString()}. );} function tick() { ReactDOM.render( , document.getElementById(‘root’) );} setInterval(tick, 1000); 无论怎样，它却少了一个关键的需求：事实上Clock建立一个计时器且每秒自动更新UI应该是一个细节上的实现。 理想情况下我们想只写一次然后它自己更新：ReactDOM.render( , document.getElementById(‘root’)); 为了实现这个，我们需要向组件中添加“state”， state比props更小，但是他是私有的，而且组件对他有完全控制权 我们曾经注意到组件作为类被定义时有一些传统的特性，本地的state正是如此： 一个只能被类使用的变量 简单概括：Converting a Function to a ClassYou can convert a functional component like Clock to a class in five steps: Create an ES6 class, with the same name, that extends React.Component. Add a single empty method to it called render(). Move the body of the function into the render() method. Replace props with this.props in the render() body. Delete the remaining empty function declaration. class Clock extends React.Component { render() { return ( Hello, world! It is {this.props.date.toLocaleTimeString()}. ); }} 现在clock组件作为类被定义，而不是函数 这使得我们可以使用附加的局部state和生命周期特性 Adding Local State to a Class 我们将会使用三个步骤从props中移除date到state中：1，在render()函数中使用this.state.date替换this.props.date,class Clock extends React.Component { render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); }}2, 添加一个类的构造器并给this.state初始化class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); }}注意我们是如何传入props到父构造器中的 类组件应该总是向父组件传入props 在元素中移除移除dete propsReactDOM.render( , document.getElementById(‘root’)); The result looks like this: class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); }} ReactDOM.render( , document.getElementById(‘root’)); Adding Lifecycle Methods to a Class In applications with many components, it’s very important to free up resources taken by the components when they are destroyed. We want to set up a timer whenever the Clock is rendered to the DOM for the first time. This is called “mounting” in React. We also want to clear that timer whenever the DOM produced by the Clock is removed. This is called “unmounting” in React. We can declare special methods on the component class to run some code when a component mounts and unmounts: class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } componentDidMount() { } componentWillUnmount() { } render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); }}These methods are called “lifecycle hooks”. The componentDidMount() hook runs after the component output has been rendered to the DOM. This is a good place to set up a timer: componentDidMount() { this.timerID = setInterval( () =&gt; this.tick(), 1000 ); } 注意到我们是将timeID保存到this上的 当this.props被react建立且this.state有一个特俗的意义，如果你需要存储一些不会显示在试图中的数据可以自由的手动添加字段到类中 不在render中使用的数据也不应该出现在state中 我们将会拆除计时器当componentWillUnmount被触发时， componentWillUnmount() { clearInterval(this.timerID); } 最终我们会实现一个叫做tick的方法，这个方法让组件每秒更新一次 他将会使用this.setState()指定组件的局部state更新 class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } componentDidMount() { this.timerID = setInterval( () =&gt; this.tick(), 1000 ); } componentWillUnmount() { clearInterval(this.timerID); } tick() { this.setState({ date: new Date() }); } render() { return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); }} ReactDOM.render( , document.getElementById(‘root’)); 现在它能够正常工作了 让我们简单总结一下是怎么回事并排序事件的触发顺序 1，当组件被传入ReactDOM.render()时，react触发了Clock组件的构造函数，自从Clock需要显示当前事件，他使用一个包含时间的对象初始化this.state，我们将会在接下来更新他。2，接着react使用了组件的render函数，这让react了解到那些数据应该在屏幕上显示，react下一步会匹配render的输出更新dom3，当Clock的输出被内嵌到dom中，react触发componentDidMount函数，再此函数中Clock要求浏览器建立一个计时器每秒呼叫组件的tick方法4，浏览器每秒呼叫tick函数，在函数中Clock计划使用setState改变当前时间去更新视图，感谢setState，react才能知道state被改变，接着使用render函数去更新那些应该在屏幕上显示的数据，这时，this.state.date将会不同于render函数中的数据，所以render函数的输出将会更新时间。5，如果组件一旦从dom中移除，react将会运行componentWillUnmount函数，所以这个计时器也被停止 事件处理","raw":"\ntitle: react props state\ndate: 2018年4月03日13:15:08\ncategories: react\ntags: [react]\ndescription: react基础\n\n组件和props\n\n组件让你按需分割界面，可重用的块，思考将这些快分割；\n\n组件的概念就像js中的函数，它们可以接受任意的参数（称为props）返回应该显示的react元素\n\n这个简单的方式定义了一个组件，使用js的函数\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n这个函数是一个有效的react组件，因为他接受了一个单一的props（标准的properties）数据对象参数并且返回一个react元素。\n我们称这样的组件为functional，因为他是字面上的js函数？\n\n**渲染组件**\n\n我们可以定义一个react元素代表传统的标签\n\nconst ele = <div />;\n\n元素也可以代表用户自定义的组件\n\n当react看见一个代表用户自定义组件的元素时，它会传入JSX属性到这个组件作为一个单一的对象，我们成这样的对象为props\n\nex：\n    function Welcome(props) {\n      return <h1>Hello, {props.name}</h1>;\n    }\n    \n    const element = <Welcome name=\"Sara\" />;\n    ReactDOM.render(\n      element,\n      document.getElementById('root')\n    );\n\n他将会输出<h1>Hello, Sara</h1>\n\n让我们总结一下在这个例子中方式发生了什么：\n- 1，我们在React.Dom中使用了<welcome name=\"Sara\">元素\n- 2，react将{name: \"Sara\"}作为props传给Welcome组件\n- 3，我们的Welcome组件返回<h1>Hello Sara</h1>结果\n- 4，react dom匹配<h1>Hello Sara</h1>有效地更新DOM\n\n注：自定义组件首字母必须大写\n<small>当一个元素以一个小写的字母开始，它指向一个内建的组件，像<div> 或者 <span> 结果将会是一个字符串'div' 或者 'span',然后传给React.creactEalement，类型以一个大写字母开始，像<Foo />，编译结果会是React.createElement(Foo),就爱那个会正确的返回一个定义的组件，或者从你的js文件中引入</small>\n\nComposing Compoents(晓不得咋个翻译额，直接引用原文还更容易理解)\nComponents can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components.\n\nFor example, we can create an App component that renders Welcome many times:\n\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n\nfunction App() {\n  return (\n    <div>\n      <Welcome name=\"Sara\" />\n      <Welcome name=\"Cahal\" />\n      <Welcome name=\"Edite\" />\n    </div>\n  );\n}\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\nExtracting Components\nDon’t be afraid to split components into smaller components.\n\nFor example, consider this Comment component:\n\nfunction Comment(props) {\n  return (\n    <div className=\"Comment\">\n      <div className=\"UserInfo\">\n        <img className=\"Avatar\"\n          src={props.author.avatarUrl}\n          alt={props.author.name}\n        />\n        <div className=\"UserInfo-name\">\n          {props.author.name}\n        </div>\n      </div>\n      <div className=\"Comment-text\">\n        {props.text}\n      </div>\n      <div className=\"Comment-date\">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n\n它接收auther，text，和date作为props，描述可一个在社交媒体网站上的评论组件\n\n改变这个组件可能会变得很棘手，因为它含有很多层的嵌套，而且它也很难复用在其他的parts。让我们从他上面分割一些组件下来。\n\n首先我们分割头像组件\n\nfunction Avatar(props) {\n  return (\n    <img className=\"Avatar\"\n      src={props.user.avatarUrl}\n      alt={props.user.name}\n    />\n\n  );\n}\n\n头像组件并不需要知道他是要在一个组件内渲染，这也是为什么我们给一个更为广泛的name: user而不是author作为props\n\n我们建议在组件中的name props在视图中有自己的重点，而不是考虑在上下文中它的使用\n\n现在我们可以使用更小一点的组件\nfunction Comment(props) {\n  return (\n    <div className=\"Comment\">\n      <div className=\"UserInfo\">\n        <Avatar user={props.author} />\n        <div className=\"UserInfo-name\">\n          {props.author.name}\n        </div>\n      </div>\n      <div className=\"Comment-text\">\n        {props.text}\n      </div>\n      <div className=\"Comment-date\">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n\n接下来我们分割一个userInfo\n\n组件渲染Avatar接下来是user‘s name\nfunction UserInfo(props) {\n  return (\n    <div className=\"UserInfo\">\n      <Avatar user={props.user} />\n      <div className=\"UserInfo-name\">\n        {props.user.name}\n      </div>\n    </div>\n  );\n}\n\n这让我们简单的组件更进一步\nfunction Comment(props) {\n  return (\n    <div className=\"Comment\">\n      <UserInfo user={props.author} />\n      <div className=\"Comment-text\">\n        {props.text}\n      </div>\n      <div className=\"Comment-date\">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n\n组件分割也许在刚开始看起来像grunt的工作，但是有一个palette装了复用组件可以在大型app中使用。一个简单的规则是如果你的一部分UI使用了几次(Button, Panel, Avatar)，或者它自己足够复杂（App, FeedStory, Comment），这是一个好的复用组件的标准\n\nprops和只读\n\n无论你是否使用function or class定义组件，他必须不能够被修改它自己的props，考虑这个求和函数\nfunction sum(a, b) {\n  return a + b;\n}\n\n像这样的函数被叫做“pure”，因为他们并不会试图去修改他们的输入，而且当输入相同时总是返回相同的结果。\n\n作为对比，这个函数不是“pure”的，因为它会改变它自己的输入\n\nreact是很灵活的，但是他有一个单一的严格规则：\n\n所有的组件都必须像pure函数以尊重他们的props\n\n\n**state and Lifecycle**\n\n到目前为止我们学习了如何更新UI\n\n我们使用ReactDOM.render()来改变渲染的输出\n\nfunction tick() {\n  const element = (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {new Date().toLocaleTimeString()}.</h2>\n    </div>\n  );\n  ReactDOM.render(\n    element,\n    document.getElementById('root')\n  );\n}\n\nsetInterval(tick, 1000);\n\n在这一章中，我们将会学习如何制作一个时钟组件，他是复用的而且封装性的，它会建立自己的计数器且每秒都会更新\n\n我们先封装一下他是什么样的\n\nfunction Clock(props) {\n  return (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {props.date.toLocaleTimeString()}.</h2>\n    </div>\n  );\n}\n\nfunction tick() {\n  ReactDOM.render(\n    <Clock date={new Date()} />,\n    document.getElementById('root')\n  );\n}\n\nsetInterval(tick, 1000);\n\n无论怎样，它却少了一个关键的需求：事实上Clock建立一个计时器且每秒自动更新UI应该是一个细节上的实现。\n\n理想情况下我们想只写一次然后它自己更新：\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n\n为了实现这个，我们需要向组件中添加“state”，\n\nstate比props更小，但是他是私有的，而且组件对他有完全控制权\n\n我们曾经注意到组件作为类被定义时有一些传统的特性，本地的state正是如此： 一个只能被类使用的变量\n\n简单概括：Converting a Function to a Class\nYou can convert a functional component like Clock to a class in five steps:\n\nCreate an ES6 class, with the same name, that extends React.Component.\n\nAdd a single empty method to it called render().\n\nMove the body of the function into the render() method.\n\nReplace props with this.props in the render() body.\n\nDelete the remaining empty function declaration.\n\nclass Clock extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.props.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\n现在clock组件作为类被定义，而不是函数\n\n这使得我们可以使用附加的局部state和生命周期特性\n\n\n**Adding Local State to a Class**\n\n我们将会使用三个步骤从props中移除date到state中：\n1，在render()函数中使用this.state.date替换this.props.date,\nclass Clock extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n2, 添加一个类的构造器并给this.state初始化\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n注意我们是如何传入props到父构造器中的\n\n\n类组件应该总是向父组件传入props\n\n在<Clock />元素中移除移除dete props\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n\nThe result looks like this:\n\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n\n**Adding Lifecycle Methods to a Class**\n\nIn applications with many components, it’s very important to free up resources taken by the components when they are destroyed.\n\nWe want to set up a timer whenever the Clock is rendered to the DOM for the first time. This is called “mounting” in React.\n\nWe also want to clear that timer whenever the DOM produced by the Clock is removed. This is called “unmounting” in React.\n\nWe can declare special methods on the component class to run some code when a component mounts and unmounts:\n\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  componentDidMount() {\n\n  }\n\n  componentWillUnmount() {\n\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\nThese methods are called “lifecycle hooks”.\n\nThe componentDidMount() hook runs after the component output has been rendered to the DOM. This is a good place to set up a timer:\n\n  componentDidMount() {\n    this.timerID = setInterval(\n      () => this.tick(),\n      1000\n    );\n  }\n\n注意到我们是将timeID保存到this上的\n\n当this.props被react建立且this.state有一个特俗的意义，如果你需要存储一些不会显示在试图中的数据可以自由的手动添加字段到类中\n\n不在render中使用的数据也不应该出现在state中\n\n我们将会拆除计时器当componentWillUnmount被触发时，\n componentWillUnmount() {\n    clearInterval(this.timerID);\n  }\n\n最终我们会实现一个叫做tick的方法，这个方法让组件每秒更新一次\n\n他将会使用this.setState()指定组件的局部state更新\n\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  componentDidMount() {\n    this.timerID = setInterval(\n      () => this.tick(),\n      1000\n    );\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timerID);\n  }\n\n  tick() {\n    this.setState({\n      date: new Date()\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n\n现在它能够正常工作了\n\n让我们简单总结一下是怎么回事并排序事件的触发顺序\n\n1，当<Clock />组件被传入ReactDOM.render()时，react触发了Clock组件的构造函数，自从Clock需要显示当前事件，他使用一个包含时间的对象初始化this.state，我们将会在接下来更新他。\n2，接着react使用了组件的render函数，这让react了解到那些数据应该在屏幕上显示，react下一步会匹配render的输出更新dom\n3，当Clock的输出被内嵌到dom中，react触发componentDidMount函数，再此函数中Clock要求浏览器建立一个计时器每秒呼叫组件的tick方法\n4，浏览器每秒呼叫tick函数，在函数中Clock计划使用setState改变当前时间去更新视图，感谢setState，react才能知道state被改变，接着使用render函数去更新那些应该在屏幕上显示的数据，这时，this.state.date将会不同于render函数中的数据，所以render函数的输出将会更新时间。\n5，如果组件一旦从dom中移除，react将会运行componentWillUnmount函数，所以这个计时器也被停止\n\n\n事件处理\n","content":"<p>title: react props state<br>date: 2018年4月03日13:15:08<br>categories: react<br>tags: [react]<br>description: react基础</p>\n<p>组件和props</p>\n<p>组件让你按需分割界面，可重用的块，思考将这些快分割；</p>\n<p>组件的概念就像js中的函数，它们可以接受任意的参数（称为props）返回应该显示的react元素</p>\n<p>这个简单的方式定义了一个组件，使用js的函数<br>function Welcome(props) {<br>  return </p><h1>Hello, {props.name}</h1>;<br>}<br>这个函数是一个有效的react组件，因为他接受了一个单一的props（标准的properties）数据对象参数并且返回一个react元素。<br>我们称这样的组件为functional，因为他是字面上的js函数？<p></p>\n<p><strong>渲染组件</strong></p>\n<p>我们可以定义一个react元素代表传统的标签</p>\n<p>const ele = <div>;</div></p>\n<p>元素也可以代表用户自定义的组件</p>\n<p>当react看见一个代表用户自定义组件的元素时，它会传入JSX属性到这个组件作为一个单一的对象，我们成这样的对象为props</p>\n<p>ex：<br>    function Welcome(props) {<br>      return </p><h1>Hello, {props.name}</h1>;<br>    }<p></p>\n<pre><code>const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;\nReactDOM.render(\n  element,\n  document.getElementById(&apos;root&apos;)\n);\n</code></pre><p>他将会输出</p><h1>Hello, Sara</h1><p></p>\n<p>让我们总结一下在这个例子中方式发生了什么：</p>\n<ul>\n<li>1，我们在React.Dom中使用了<welcome name=\"Sara\">元素</welcome></li>\n<li>2，react将{name: “Sara”}作为props传给Welcome组件</li>\n<li>3，我们的Welcome组件返回<h1>Hello Sara</h1>结果</li>\n<li>4，react dom匹配<h1>Hello Sara</h1>有效地更新DOM</li>\n</ul>\n<p>注：自定义组件首字母必须大写<br><small>当一个元素以一个小写的字母开始，它指向一个内建的组件，像<div> 或者 <span> 结果将会是一个字符串’div’ 或者 ‘span’,然后传给React.creactEalement，类型以一个大写字母开始，像<foo>，编译结果会是React.createElement(Foo),就爱那个会正确的返回一个定义的组件，或者从你的js文件中引入</foo></span></div></small></p>\n<p>Composing Compoents(晓不得咋个翻译额，直接引用原文还更容易理解)<br>Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components.</p>\n<p>For example, we can create an App component that renders Welcome many times:</p>\n<p>function Welcome(props) {<br>  return </p><h1>Hello, {props.name}</h1>;<br>}<p></p>\n<p>function App() {<br>  return (<br>    <div><br>      <welcome name=\"Sara\"><br>      <welcome name=\"Cahal\"><br>      <welcome name=\"Edite\"><br>    </welcome></welcome></welcome></div><br>  );<br>}</p>\n<p>ReactDOM.render(<br>  <app>,<br>  document.getElementById(‘root’)<br>);</app></p>\n<p>Extracting Components<br>Don’t be afraid to split components into smaller components.</p>\n<p>For example, consider this Comment component:</p>\n<p>function Comment(props) {<br>  return (<br>    <div classname=\"Comment\"><br>      <div classname=\"UserInfo\"><br>        <img classname=\"Avatar\" src=\"{props.author.avatarUrl}\" alt=\"{props.author.name}\"><br>        <div classname=\"UserInfo-name\"><br>          {props.author.name}<br>        </div><br>      </div><br>      <div classname=\"Comment-text\"><br>        {props.text}<br>      </div><br>      <div classname=\"Comment-date\"><br>        {formatDate(props.date)}<br>      </div><br>    </div><br>  );<br>}</p>\n<p>它接收auther，text，和date作为props，描述可一个在社交媒体网站上的评论组件</p>\n<p>改变这个组件可能会变得很棘手，因为它含有很多层的嵌套，而且它也很难复用在其他的parts。让我们从他上面分割一些组件下来。</p>\n<p>首先我们分割头像组件</p>\n<p>function Avatar(props) {<br>  return (<br>    <img classname=\"Avatar\" src=\"{props.user.avatarUrl}\" alt=\"{props.user.name}\"></p>\n<p>  );<br>}</p>\n<p>头像组件并不需要知道他是要在一个组件内渲染，这也是为什么我们给一个更为广泛的name: user而不是author作为props</p>\n<p>我们建议在组件中的name props在视图中有自己的重点，而不是考虑在上下文中它的使用</p>\n<p>现在我们可以使用更小一点的组件<br>function Comment(props) {<br>  return (<br>    <div classname=\"Comment\"><br>      <div classname=\"UserInfo\"><br>        <avatar user=\"{props.author}\"><br>        <div classname=\"UserInfo-name\"><br>          {props.author.name}<br>        </div><br>      </avatar></div><br>      <div classname=\"Comment-text\"><br>        {props.text}<br>      </div><br>      <div classname=\"Comment-date\"><br>        {formatDate(props.date)}<br>      </div><br>    </div><br>  );<br>}</p>\n<p>接下来我们分割一个userInfo</p>\n<p>组件渲染Avatar接下来是user‘s name<br>function UserInfo(props) {<br>  return (<br>    <div classname=\"UserInfo\"><br>      <avatar user=\"{props.user}\"><br>      <div classname=\"UserInfo-name\"><br>        {props.user.name}<br>      </div><br>    </avatar></div><br>  );<br>}</p>\n<p>这让我们简单的组件更进一步<br>function Comment(props) {<br>  return (<br>    <div classname=\"Comment\"><br>      <userinfo user=\"{props.author}\"><br>      <div classname=\"Comment-text\"><br>        {props.text}<br>      </div><br>      <div classname=\"Comment-date\"><br>        {formatDate(props.date)}<br>      </div><br>    </userinfo></div><br>  );<br>}</p>\n<p>组件分割也许在刚开始看起来像grunt的工作，但是有一个palette装了复用组件可以在大型app中使用。一个简单的规则是如果你的一部分UI使用了几次(Button, Panel, Avatar)，或者它自己足够复杂（App, FeedStory, Comment），这是一个好的复用组件的标准</p>\n<p>props和只读</p>\n<p>无论你是否使用function or class定义组件，他必须不能够被修改它自己的props，考虑这个求和函数<br>function sum(a, b) {<br>  return a + b;<br>}</p>\n<p>像这样的函数被叫做“pure”，因为他们并不会试图去修改他们的输入，而且当输入相同时总是返回相同的结果。</p>\n<p>作为对比，这个函数不是“pure”的，因为它会改变它自己的输入</p>\n<p>react是很灵活的，但是他有一个单一的严格规则：</p>\n<p>所有的组件都必须像pure函数以尊重他们的props</p>\n<p><strong>state and Lifecycle</strong></p>\n<p>到目前为止我们学习了如何更新UI</p>\n<p>我们使用ReactDOM.render()来改变渲染的输出</p>\n<p>function tick() {<br>  const element = (<br>    <div><br>      <h1>Hello, world!</h1><br>      <h2>It is {new Date().toLocaleTimeString()}.</h2><br>    </div><br>  );<br>  ReactDOM.render(<br>    element,<br>    document.getElementById(‘root’)<br>  );<br>}</p>\n<p>setInterval(tick, 1000);</p>\n<p>在这一章中，我们将会学习如何制作一个时钟组件，他是复用的而且封装性的，它会建立自己的计数器且每秒都会更新</p>\n<p>我们先封装一下他是什么样的</p>\n<p>function Clock(props) {<br>  return (<br>    <div><br>      <h1>Hello, world!</h1><br>      <h2>It is {props.date.toLocaleTimeString()}.</h2><br>    </div><br>  );<br>}</p>\n<p>function tick() {<br>  ReactDOM.render(<br>    <clock date=\"{new\" date()}=\"\">,<br>    document.getElementById(‘root’)<br>  );<br>}</clock></p>\n<p>setInterval(tick, 1000);</p>\n<p>无论怎样，它却少了一个关键的需求：事实上Clock建立一个计时器且每秒自动更新UI应该是一个细节上的实现。</p>\n<p>理想情况下我们想只写一次然后它自己更新：<br>ReactDOM.render(<br>  <clock>,<br>  document.getElementById(‘root’)<br>);</clock></p>\n<p>为了实现这个，我们需要向组件中添加“state”，</p>\n<p>state比props更小，但是他是私有的，而且组件对他有完全控制权</p>\n<p>我们曾经注意到组件作为类被定义时有一些传统的特性，本地的state正是如此： 一个只能被类使用的变量</p>\n<p>简单概括：Converting a Function to a Class<br>You can convert a functional component like Clock to a class in five steps:</p>\n<p>Create an ES6 class, with the same name, that extends React.Component.</p>\n<p>Add a single empty method to it called render().</p>\n<p>Move the body of the function into the render() method.</p>\n<p>Replace props with this.props in the render() body.</p>\n<p>Delete the remaining empty function declaration.</p>\n<p>class Clock extends React.Component {<br>  render() {<br>    return (<br>      <div><br>        <h1>Hello, world!</h1><br>        <h2>It is {this.props.date.toLocaleTimeString()}.</h2><br>      </div><br>    );<br>  }<br>}</p>\n<p>现在clock组件作为类被定义，而不是函数</p>\n<p>这使得我们可以使用附加的局部state和生命周期特性</p>\n<p><strong>Adding Local State to a Class</strong></p>\n<p>我们将会使用三个步骤从props中移除date到state中：<br>1，在render()函数中使用this.state.date替换this.props.date,<br>class Clock extends React.Component {<br>  render() {<br>    return (<br>      <div><br>        <h1>Hello, world!</h1><br>        <h2>It is {this.state.date.toLocaleTimeString()}.</h2><br>      </div><br>    );<br>  }<br>}<br>2, 添加一个类的构造器并给this.state初始化<br>class Clock extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {date: new Date()};<br>  }</p>\n<p>  render() {<br>    return (<br>      <div><br>        <h1>Hello, world!</h1><br>        <h2>It is {this.state.date.toLocaleTimeString()}.</h2><br>      </div><br>    );<br>  }<br>}<br>注意我们是如何传入props到父构造器中的</p>\n<p>类组件应该总是向父组件传入props</p>\n<p>在<clock>元素中移除移除dete props<br>ReactDOM.render(<br>  <clock>,<br>  document.getElementById(‘root’)<br>);</clock></clock></p>\n<p>The result looks like this:</p>\n<p>class Clock extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {date: new Date()};<br>  }</p>\n<p>  render() {<br>    return (<br>      <div><br>        <h1>Hello, world!</h1><br>        <h2>It is {this.state.date.toLocaleTimeString()}.</h2><br>      </div><br>    );<br>  }<br>}</p>\n<p>ReactDOM.render(<br>  <clock>,<br>  document.getElementById(‘root’)<br>);</clock></p>\n<p><strong>Adding Lifecycle Methods to a Class</strong></p>\n<p>In applications with many components, it’s very important to free up resources taken by the components when they are destroyed.</p>\n<p>We want to set up a timer whenever the Clock is rendered to the DOM for the first time. This is called “mounting” in React.</p>\n<p>We also want to clear that timer whenever the DOM produced by the Clock is removed. This is called “unmounting” in React.</p>\n<p>We can declare special methods on the component class to run some code when a component mounts and unmounts:</p>\n<p>class Clock extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {date: new Date()};<br>  }</p>\n<p>  componentDidMount() {</p>\n<p>  }</p>\n<p>  componentWillUnmount() {</p>\n<p>  }</p>\n<p>  render() {<br>    return (<br>      <div><br>        <h1>Hello, world!</h1><br>        <h2>It is {this.state.date.toLocaleTimeString()}.</h2><br>      </div><br>    );<br>  }<br>}<br>These methods are called “lifecycle hooks”.</p>\n<p>The componentDidMount() hook runs after the component output has been rendered to the DOM. This is a good place to set up a timer:</p>\n<p>  componentDidMount() {<br>    this.timerID = setInterval(<br>      () =&gt; this.tick(),<br>      1000<br>    );<br>  }</p>\n<p>注意到我们是将timeID保存到this上的</p>\n<p>当this.props被react建立且this.state有一个特俗的意义，如果你需要存储一些不会显示在试图中的数据可以自由的手动添加字段到类中</p>\n<p>不在render中使用的数据也不应该出现在state中</p>\n<p>我们将会拆除计时器当componentWillUnmount被触发时，<br> componentWillUnmount() {<br>    clearInterval(this.timerID);<br>  }</p>\n<p>最终我们会实现一个叫做tick的方法，这个方法让组件每秒更新一次</p>\n<p>他将会使用this.setState()指定组件的局部state更新</p>\n<p>class Clock extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {date: new Date()};<br>  }</p>\n<p>  componentDidMount() {<br>    this.timerID = setInterval(<br>      () =&gt; this.tick(),<br>      1000<br>    );<br>  }</p>\n<p>  componentWillUnmount() {<br>    clearInterval(this.timerID);<br>  }</p>\n<p>  tick() {<br>    this.setState({<br>      date: new Date()<br>    });<br>  }</p>\n<p>  render() {<br>    return (<br>      <div><br>        <h1>Hello, world!</h1><br>        <h2>It is {this.state.date.toLocaleTimeString()}.</h2><br>      </div><br>    );<br>  }<br>}</p>\n<p>ReactDOM.render(<br>  <clock>,<br>  document.getElementById(‘root’)<br>);</clock></p>\n<p>现在它能够正常工作了</p>\n<p>让我们简单总结一下是怎么回事并排序事件的触发顺序</p>\n<p>1，当<clock>组件被传入ReactDOM.render()时，react触发了Clock组件的构造函数，自从Clock需要显示当前事件，他使用一个包含时间的对象初始化this.state，我们将会在接下来更新他。<br>2，接着react使用了组件的render函数，这让react了解到那些数据应该在屏幕上显示，react下一步会匹配render的输出更新dom<br>3，当Clock的输出被内嵌到dom中，react触发componentDidMount函数，再此函数中Clock要求浏览器建立一个计时器每秒呼叫组件的tick方法<br>4，浏览器每秒呼叫tick函数，在函数中Clock计划使用setState改变当前时间去更新视图，感谢setState，react才能知道state被改变，接着使用render函数去更新那些应该在屏幕上显示的数据，这时，this.state.date将会不同于render函数中的数据，所以render函数的输出将会更新时间。<br>5，如果组件一旦从dom中移除，react将会运行componentWillUnmount函数，所以这个计时器也被停止</clock></p>\n<p>事件处理</p>\n","comments":true,"categories":[],"tags":[]}]